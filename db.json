{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":1,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":1,"renderable":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":1,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":1,"renderable":1},{"_id":"themes/fexo/source/sass/component/prev-net.scss","path":"sass/component/prev-net.scss","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":1,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1486187677000},{"_id":"themes/fexo/.gitignore","hash":"32223fbe296f8e3026c689bad8f3dea9d0fcbb43","modified":1486187677000},{"_id":"themes/fexo/LICENSE","hash":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1486187677000},{"_id":"themes/fexo/README.md","hash":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1486187677000},{"_id":"themes/fexo/_config.yml","hash":"6ad3966fb7ee39139e34d856834e0d54fbad6adc","modified":1489409177700},{"_id":"themes/fexo/gulpfile.js","hash":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1486187677000},{"_id":"themes/fexo/package.json","hash":"351b5b21f5ea8851103ee1891248be43f3c27027","modified":1486187677000},{"_id":"source/_posts/ByteArrayInputStream.md","hash":"25cf9f17972ee959a03065fb6ebe2d584e3c7213","modified":1488290735476},{"_id":"source/_posts/Java-IO.md","hash":"27dc430491e1b3fa4b5190e6f86e81dc226a3d75","modified":1488203282783},{"_id":"source/_posts/TensorFlow.md","hash":"8eb3379b2fb939bb15235de8473e03f3a76aaa43","modified":1488100891052},{"_id":"source/_posts/Ubuntu-Android-NDK.md","hash":"fd82bd4d8a3e111e529dce22843b6b308b5588df","modified":1488100282469},{"_id":"source/_posts/Ubuntun-set-environment.md","hash":"837dc4ebf15f8aca9b876f89b42ac1436d91545e","modified":1488098282343},{"_id":"source/_posts/debug-android-source.md","hash":"10259bfcabffb0a88cb1d2536033523005032aff","modified":1489408855011},{"_id":"source/_posts/git.md","hash":"b42517df10151621d38f63667559df93b755ffb4","modified":1490879248570},{"_id":"source/_posts/loopviewpager.md","hash":"2a65932bdd868cbae27ba9958a78f203b5e19440","modified":1489326279635},{"_id":"source/_posts/sharedPreferences.md","hash":"41b8fd0062bb5d4b44cb74b340a0f610540b5cbd","modified":1489585329321},{"_id":"source/_posts/systemgc.md","hash":"1f410969470e4a57321f8f74e618cc2664ce10f5","modified":1490879171925},{"_id":"source/_posts/viewpager-webview.md","hash":"669146802d04a8430817eb53c8b37cd826df72e1","modified":1489319401103},{"_id":"source/about/index.md","hash":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1488094068052},{"_id":"source/category/index.md","hash":"e599870f1d023dfddd75e5e89fd1724b6b12aa74","modified":1488094068052},{"_id":"source/project/index.md","hash":"fdf7ecc245ccfc593aa5b10cfb58ca003f600420","modified":1488094068052},{"_id":"source/tag/index.md","hash":"7de81a09ff31847ac8131fac8ab7a0ebe1466ad8","modified":1488094068052},{"_id":"themes/fexo/languages/default.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1486187677000},{"_id":"themes/fexo/languages/en.yml","hash":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1486187677000},{"_id":"themes/fexo/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1486187677000},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1486187677000},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1486187677000},{"_id":"themes/fexo/layout/about.ejs","hash":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1486187677000},{"_id":"themes/fexo/layout/archive.ejs","hash":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1486187677000},{"_id":"themes/fexo/layout/category.ejs","hash":"6d7f43a3d3180e7eb120601bae701664911cf8e6","modified":1486187677000},{"_id":"themes/fexo/layout/index.ejs","hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1486187677000},{"_id":"themes/fexo/layout/layout.ejs","hash":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1486187677000},{"_id":"themes/fexo/layout/link.ejs","hash":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1486187677000},{"_id":"themes/fexo/layout/post.ejs","hash":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1486187677000},{"_id":"themes/fexo/layout/project.ejs","hash":"6648041e1319c8ee3e16c882b33bb457c67a9527","modified":1486187677000},{"_id":"themes/fexo/layout/search.ejs","hash":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1486187677000},{"_id":"themes/fexo/layout/tag.ejs","hash":"2cadf0acdf7c8e76bd4f27c6d7fe97eefe42ef5e","modified":1486187677000},{"_id":"source/_posts/ByteArrayInputStream/bytearrayinputstream.png","hash":"aa59865c33dc709e165e71648023bc1d10727bac","modified":1488285825076},{"_id":"source/_posts/ByteArrayInputStream/fileinputstream.png","hash":"79c7af044556b5e06f9f41eeec6d1cbb2ec9502c","modified":1488287086478},{"_id":"source/_posts/ByteArrayInputStream/filterinputstream.png","hash":"6c54a4b8ca42bcf6a7f99fb8b74713443a8d3e78","modified":1488290155013},{"_id":"source/_posts/Java-IO/file.jpg","hash":"16336b5cb2d6f7289d3eb4b3f907d5c01c6cb086","modified":1488202668088},{"_id":"source/_posts/Java-IO/inputstream.png","hash":"6f20a0c7618b3450ec0d72b7963d4e4e5694866c","modified":1488200975016},{"_id":"source/_posts/Java-IO/outputstream.png","hash":"82e721832ed52195efadd4234ce0b9c6aa86d302","modified":1488202266022},{"_id":"source/_posts/Java-IO/reader.png","hash":"5f98479726b09c0891339a954bbe2805dc956912","modified":1488202477846},{"_id":"source/_posts/Java-IO/socket.jpg","hash":"e4443287e9fda0a9590ff0fd6db152b82a3d7f6c","modified":1488202905676},{"_id":"source/_posts/Java-IO/writer.png","hash":"e1654dde9d608d741725ee21810a98ae561d520b","modified":1488202466944},{"_id":"source/_posts/debug-android-source/android.jpg","hash":"d6c1b47aad0f37e88ea626ffbffe0086d0cc856b","modified":1489408463312},{"_id":"source/_posts/debug-android-source/error.png","hash":"3a870f3231f189e74b14f7f98e1164d42451f8e3","modified":1489408060653},{"_id":"source/_posts/debug-android-source/right.png","hash":"ddae401e16f91781c89ddde9932baa8d28000f2d","modified":1489408081068},{"_id":"source/_posts/debug-android-source/sdk_manager.png","hash":"6fe46bba2cde0b64dc093c4377c3c7d7da86e6b3","modified":1489406122602},{"_id":"source/_posts/loopviewpager/final.png","hash":"cd0a0887f4492fb2a1b3171339bf747816405b75","modified":1489324224754},{"_id":"source/_posts/loopviewpager/mdify.png","hash":"65ffc67eb2381636144fc54b0dc27f439c277b3c","modified":1489322398522},{"_id":"source/_posts/loopviewpager/modify2.png","hash":"149fefcba11cc5a6acccffe3720aeadfe5171b11","modified":1489323104630},{"_id":"source/_posts/loopviewpager/origin.png","hash":"4ea4faa9fa16743bb12cfe71d218ba9a3ff49258","modified":1489321753939},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"ab0adc8f18a96eab18bb584233c0e8d4ddba71fc","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1486187677000},{"_id":"themes/fexo/source/css/styles.css","hash":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1486187677000},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"82847252dc8b5408437a50a35f07b4fcbc240335","modified":1487837802788},{"_id":"themes/fexo/source/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1486187677000},{"_id":"themes/fexo/source/js/bundle.js","hash":"7da160b15a43ce19273ec85204828bd42628546f","modified":1486187677000},{"_id":"themes/fexo/source/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1486187677000},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1486187677000},{"_id":"themes/fexo/source/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1486187677000},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1486187677000},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1486187677000},{"_id":"themes/fexo/source/sass/_base.scss","hash":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1486187677000},{"_id":"themes/fexo/source/sass/_common.scss","hash":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1486187677000},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1486187677000},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"10e188d379782ae2ee10427544919557036d0137","modified":1486187677000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1486187677000},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1486187677000},{"_id":"themes/fexo/source/sass/_type.scss","hash":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1486187677000},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1486187677000},{"_id":"themes/fexo/source/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1486187677000},{"_id":"themes/fexo/source/css/styles.css.map","hash":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"043ed1e5625860696fe42bb88c998668faf71449","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"65bf93ad8e149033e6f93d673cc85ee223615589","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/duoshuo.ejs","hash":"b732200315e4c82e92bc7bd0ad33eb171d246e26","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"172a3d5f747ba028d7e10e6f03ebc1db4d487a54","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/prev-net.scss","hash":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"bcbaded3d378bbaa1497f4c3843994ea589f3149","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1486187677000},{"_id":"public/about/index.html","hash":"e382b83109bf3dbf8b0bb34aee28a5fef8b092da","modified":1490879263000},{"_id":"public/category/index.html","hash":"da80a1534441ce3f32eb551772303c4196230315","modified":1490879263030},{"_id":"public/project/index.html","hash":"e761e3c18321c53ae17247380b514dc1e3b532f6","modified":1490879263032},{"_id":"public/tag/index.html","hash":"1db67acafc04f487919b51387a01e960a204170b","modified":1490879263032},{"_id":"public/2017/03/15/sharedPreferences/index.html","hash":"ed6cb28b466aac06654d417386716b0a54353b6c","modified":1490879263032},{"_id":"public/2017/03/13/debug-android-source/index.html","hash":"e3ce47b42109f7ae100a7304c29dda916cc40055","modified":1490879263032},{"_id":"public/2017/03/12/loopviewpager/index.html","hash":"59901bb0884539c6435f1115844df25d872e94dc","modified":1490879263033},{"_id":"public/2017/02/26/TensorFlow/index.html","hash":"b408623e41cd47b13deb452aa2c15f2f1ef01693","modified":1490879263033},{"_id":"public/2017/02/26/Ubuntu-Android-NDK/index.html","hash":"aca3837e69d96cd3b36e1a32310a4628b7d8f6ad","modified":1490879263033},{"_id":"public/2017/02/26/Ubuntun-set-environment/index.html","hash":"2fbe60a1644ac79148be140cb691418df016d744","modified":1490879263033},{"_id":"public/archives/index.html","hash":"53e71015e32d3c57260ca14dac31bcade0e28550","modified":1490879263033},{"_id":"public/archives/2017/index.html","hash":"8127b7e8a41e9755133e07343c7502171ab52301","modified":1490879263033},{"_id":"public/archives/2017/02/index.html","hash":"6a15d8c4340d5a0cfffceabffa07ff5112822470","modified":1490879263033},{"_id":"public/archives/2017/03/index.html","hash":"79b11eb56fa944c28ddc88ca598abcaade9383f3","modified":1490879263033},{"_id":"public/categories/Java/index.html","hash":"ef966ca903dd26006b4e76ad3378a5f669ded6b1","modified":1490879263033},{"_id":"public/categories/Java-I-O/index.html","hash":"0c73de35c5068e4c218176785bbe058d156696bb","modified":1490879263033},{"_id":"public/categories/TensorFlow-Android/index.html","hash":"e512686a1aad9d384945c4dfaa21d8e93a6af88f","modified":1490879263033},{"_id":"public/categories/Ubuntu/index.html","hash":"0795dfccad629bd6780e4fede94cee5ce7a99142","modified":1490879263033},{"_id":"public/categories/Android/index.html","hash":"179641e5ee1f1835e1300118c62febfc4498bb1a","modified":1490879263033},{"_id":"public/index.html","hash":"f92cafbd73ed5003f7255fa47a5a1a9d8b5e0e9f","modified":1490879263033},{"_id":"public/tags/Java/index.html","hash":"8ca8245ca9e79386b787c2d3a119754303b37e36","modified":1490879263033},{"_id":"public/tags/Java-I-O/index.html","hash":"4b63788649880b9ff082a5e1a9cd17c7d8d49df1","modified":1490879263033},{"_id":"public/tags/TensorFlow-Android/index.html","hash":"c3b871f46a8a71e227a956f31367c5b2a09a79d7","modified":1490879263033},{"_id":"public/tags/Ubuntu/index.html","hash":"2833912232ea0e60e8cd4473fc5aa3371a3a75f0","modified":1490879263033},{"_id":"public/tags/Ubuntu-Android/index.html","hash":"a4c2cc2a3f362de88cd0b6dbfd21f7ff8f57a1f7","modified":1490879263033},{"_id":"public/tags/Android/index.html","hash":"da5282cec874a6af304632e639682569228065e6","modified":1490879263033},{"_id":"public/2017/03/12/viewpager-webview/index.html","hash":"53b766c92697d710330c4e90ae6a954eb552e657","modified":1490879263033},{"_id":"public/2017/02/28/ByteArrayInputStream/index.html","hash":"81c68b282e17b8c2165d7cdf535f5fb6ba2edfef","modified":1490879263033},{"_id":"public/2017/02/27/Java-IO/index.html","hash":"f6d6c5a376fb5ddc04e1c866c0ceedda14dfcc03","modified":1490879263033},{"_id":"public/2017/03/30/git/index.html","hash":"aa5f25c1abaf64368c69e4b3a9f4caff85054d20","modified":1490879263057},{"_id":"public/2017/03/30/systemgc/index.html","hash":"fd0ae327d85291896912896240e09708dd132f95","modified":1490879263057},{"_id":"public/archives/page/2/index.html","hash":"f2e275fe6d6db610d0e4b88444e4baa260e424f9","modified":1490879263057},{"_id":"public/archives/2017/page/2/index.html","hash":"1a2e7af7f0563b71a747778506fdb4475d7c4b4e","modified":1490879263057},{"_id":"public/categories/git/index.html","hash":"d1f800e59e9db2af604c233b019115ccf2dd7c24","modified":1490879263058},{"_id":"public/page/2/index.html","hash":"cb138d31e2116b142dd8456bd5e327b0d0b90514","modified":1490879263058},{"_id":"public/tags/git/index.html","hash":"ae72f7255f60fb9091cc88d2b19cfd90ea52da9f","modified":1490879263058},{"_id":"public/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1490879263068},{"_id":"public/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1490879263068},{"_id":"public/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1490879263068},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1490879263068},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1490879263069},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1490879263069},{"_id":"public/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1490879263069},{"_id":"public/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1490879263069},{"_id":"public/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1490879263069},{"_id":"public/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1490879263069},{"_id":"public/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1490879263069},{"_id":"public/images/avatar.jpg","hash":"82847252dc8b5408437a50a35f07b4fcbc240335","modified":1490879263069},{"_id":"public/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1490879263069},{"_id":"public/sass/component/prev-net.scss","hash":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1490879263069},{"_id":"public/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png","hash":"aa59865c33dc709e165e71648023bc1d10727bac","modified":1490879263069},{"_id":"public/2017/02/28/ByteArrayInputStream/fileinputstream.png","hash":"79c7af044556b5e06f9f41eeec6d1cbb2ec9502c","modified":1490879263069},{"_id":"public/2017/02/28/ByteArrayInputStream/filterinputstream.png","hash":"6c54a4b8ca42bcf6a7f99fb8b74713443a8d3e78","modified":1490879263069},{"_id":"public/2017/03/13/debug-android-source/android.jpg","hash":"d6c1b47aad0f37e88ea626ffbffe0086d0cc856b","modified":1490879263069},{"_id":"public/2017/03/13/debug-android-source/error.png","hash":"3a870f3231f189e74b14f7f98e1164d42451f8e3","modified":1490879263069},{"_id":"public/2017/03/13/debug-android-source/right.png","hash":"ddae401e16f91781c89ddde9932baa8d28000f2d","modified":1490879263069},{"_id":"public/2017/03/13/debug-android-source/sdk_manager.png","hash":"6fe46bba2cde0b64dc093c4377c3c7d7da86e6b3","modified":1490879263069},{"_id":"public/2017/03/12/loopviewpager/final.png","hash":"cd0a0887f4492fb2a1b3171339bf747816405b75","modified":1490879263069},{"_id":"public/2017/03/12/loopviewpager/mdify.png","hash":"65ffc67eb2381636144fc54b0dc27f439c277b3c","modified":1490879263069},{"_id":"public/2017/03/12/loopviewpager/modify2.png","hash":"149fefcba11cc5a6acccffe3720aeadfe5171b11","modified":1490879263069},{"_id":"public/2017/03/12/loopviewpager/origin.png","hash":"4ea4faa9fa16743bb12cfe71d218ba9a3ff49258","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/file.jpg","hash":"16336b5cb2d6f7289d3eb4b3f907d5c01c6cb086","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/inputstream.png","hash":"6f20a0c7618b3450ec0d72b7963d4e4e5694866c","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/outputstream.png","hash":"82e721832ed52195efadd4234ce0b9c6aa86d302","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/socket.jpg","hash":"e4443287e9fda0a9590ff0fd6db152b82a3d7f6c","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/reader.png","hash":"5f98479726b09c0891339a954bbe2805dc956912","modified":1490879263069},{"_id":"public/2017/02/27/Java-IO/writer.png","hash":"e1654dde9d608d741725ee21810a98ae561d520b","modified":1490879263070},{"_id":"public/css/styles.css.map","hash":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1490879263074},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1490879263077},{"_id":"public/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1490879263081},{"_id":"public/js/bundle.js","hash":"7da160b15a43ce19273ec85204828bd42628546f","modified":1490879263081},{"_id":"public/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1490879263081},{"_id":"public/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1490879263081},{"_id":"public/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1490879263081},{"_id":"public/css/styles.css","hash":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1490879263081},{"_id":"public/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1490879263081},{"_id":"public/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1490879263081},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1490879263081},{"_id":"public/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1490879263092},{"_id":"public/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1490879263092},{"_id":"public/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1490879263092},{"_id":"public/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1490879263098}],"Category":[{"name":"Java","_id":"cj0wf0ovu00034u2db8mzoerx"},{"name":"Java,I/O","_id":"cj0wf0ow300084u2dobw3dxxw"},{"name":"TensorFlow,Android","_id":"cj0wf0owa000e4u2dn6tac8dt"},{"name":"Ubuntu","_id":"cj0wf0owg000k4u2ddbzayf20"},{"name":"Android","_id":"cj0wf0owj000q4u2dgtlzi7um"},{"name":"git","_id":"cj0wf0own000y4u2dallq9km3"}],"Data":[],"Page":[{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"about/index.html","_id":"cj0wf0ovr00014u2dg375tou3","content":"","excerpt":"","more":""},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle:  category\nlayout:  category\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"category/index.html","_id":"cj0wf0oxd001k4u2do5j8es4c","content":"","excerpt":"","more":""},{"title":"project","layout":"project","comments":0,"_content":"","source":"project/index.md","raw":"---\ntitle: project\nlayout: project\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"project/index.html","_id":"cj0wf0oxe001l4u2dkvkcvck7","content":"","excerpt":"","more":""},{"title":"tag","layout":"tag","comments":0,"_content":"\n","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"tag/index.html","_id":"cj0wf0oxg001m4u2ddaxsjkwh","content":"","excerpt":"","more":""}],"Post":[{"title":"Java I/O系列之InputStream","_content":"## 1.ByteArrayInputStream\nByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。\n\n### 1.1 结构\n{% asset_img bytearrayinputstream.png ByteArrayInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从此输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public void mark(int read)|设置流中的当前标记位置。|\n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n \n 注意：\n\n* new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区\n* ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)\n \n## 2.FileInputStream\nFileInputStream是文件输入流，用于读取文件中的字节。\n\n### 2.1结构\n{% asset_img fileinputstream.png FileInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n|public final FileDescriptor getFD() ||\n|public FileChannel getChannel()||\n\n## 3.FilterInputStream\nFilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。\n\n* BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。\n\n* DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。\n\n* PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。\n\n### 3.1 结构\n{% asset_img filterinputstream.png FilterInputStream的结构图 %}\n\n## 4.ObjectInputStream\nObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。\n\nObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。\n\nObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.\n\n```\n需要实现 java.io.Serializable 或 java.io.Externalizable的接口 \n```\n## 5.PipedInputStream\n在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。\n","source":"_posts/ByteArrayInputStream.md","raw":"---\ntitle: Java I/O系列之InputStream\ncategories: Java\ntags: Java\n---\n## 1.ByteArrayInputStream\nByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。\n\n### 1.1 结构\n{% asset_img bytearrayinputstream.png ByteArrayInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从此输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public void mark(int read)|设置流中的当前标记位置。|\n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n \n 注意：\n\n* new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区\n* ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)\n \n## 2.FileInputStream\nFileInputStream是文件输入流，用于读取文件中的字节。\n\n### 2.1结构\n{% asset_img fileinputstream.png FileInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n|public final FileDescriptor getFD() ||\n|public FileChannel getChannel()||\n\n## 3.FilterInputStream\nFilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。\n\n* BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。\n\n* DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。\n\n* PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。\n\n### 3.1 结构\n{% asset_img filterinputstream.png FilterInputStream的结构图 %}\n\n## 4.ObjectInputStream\nObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。\n\nObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。\n\nObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.\n\n```\n需要实现 java.io.Serializable 或 java.io.Externalizable的接口 \n```\n## 5.PipedInputStream\n在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。\n","slug":"ByteArrayInputStream","published":1,"date":"2017-02-28T14:05:35.476Z","updated":"2017-02-28T14:05:35.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ovm00004u2dwk375zt5","content":"<h2 id=\"1-ByteArrayInputStream\"><a href=\"#1-ByteArrayInputStream\" class=\"headerlink\" title=\"1.ByteArrayInputStream\"></a>1.ByteArrayInputStream</h2><p>ByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。</p>\n<h3 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png\" alt=\"ByteArrayInputStream结构图\" title=\"ByteArrayInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从此输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public void mark(int read)</td>\n<td>设置流中的当前标记位置。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n</tbody>\n</table>\n<p> 注意：</p>\n<ul>\n<li>new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区</li>\n<li>ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)</li>\n</ul>\n<h2 id=\"2-FileInputStream\"><a href=\"#2-FileInputStream\" class=\"headerlink\" title=\"2.FileInputStream\"></a>2.FileInputStream</h2><p>FileInputStream是文件输入流，用于读取文件中的字节。</p>\n<h3 id=\"2-1结构\"><a href=\"#2-1结构\" class=\"headerlink\" title=\"2.1结构\"></a>2.1结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/fileinputstream.png\" alt=\"FileInputStream结构图\" title=\"FileInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n<tr>\n<td>public final FileDescriptor getFD()</td>\n<td></td>\n</tr>\n<tr>\n<td>public FileChannel getChannel()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-FilterInputStream\"><a href=\"#3-FilterInputStream\" class=\"headerlink\" title=\"3.FilterInputStream\"></a>3.FilterInputStream</h2><p>FilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。</p>\n<ul>\n<li><p>BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。</p>\n</li>\n<li><p>DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>\n</li>\n<li><p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n</li>\n</ul>\n<h3 id=\"3-1-结构\"><a href=\"#3-1-结构\" class=\"headerlink\" title=\"3.1 结构\"></a>3.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/filterinputstream.png\" alt=\"FilterInputStream的结构图\" title=\"FilterInputStream的结构图\">\n<h2 id=\"4-ObjectInputStream\"><a href=\"#4-ObjectInputStream\" class=\"headerlink\" title=\"4.ObjectInputStream\"></a>4.ObjectInputStream</h2><p>ObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。</p>\n<p>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。</p>\n<p>ObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">需要实现 java.io.Serializable 或 java.io.Externalizable的接口</div></pre></td></tr></table></figure>\n<h2 id=\"5-PipedInputStream\"><a href=\"#5-PipedInputStream\" class=\"headerlink\" title=\"5.PipedInputStream\"></a>5.PipedInputStream</h2><p>在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>\n","excerpt":"","more":"<h2 id=\"1-ByteArrayInputStream\"><a href=\"#1-ByteArrayInputStream\" class=\"headerlink\" title=\"1.ByteArrayInputStream\"></a>1.ByteArrayInputStream</h2><p>ByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。</p>\n<h3 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png\" alt=\"ByteArrayInputStream结构图\" title=\"ByteArrayInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从此输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public void mark(int read)</td>\n<td>设置流中的当前标记位置。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n</tbody>\n</table>\n<p> 注意：</p>\n<ul>\n<li>new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区</li>\n<li>ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)</li>\n</ul>\n<h2 id=\"2-FileInputStream\"><a href=\"#2-FileInputStream\" class=\"headerlink\" title=\"2.FileInputStream\"></a>2.FileInputStream</h2><p>FileInputStream是文件输入流，用于读取文件中的字节。</p>\n<h3 id=\"2-1结构\"><a href=\"#2-1结构\" class=\"headerlink\" title=\"2.1结构\"></a>2.1结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/fileinputstream.png\" alt=\"FileInputStream结构图\" title=\"FileInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n<tr>\n<td>public final FileDescriptor getFD()</td>\n<td></td>\n</tr>\n<tr>\n<td>public FileChannel getChannel()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-FilterInputStream\"><a href=\"#3-FilterInputStream\" class=\"headerlink\" title=\"3.FilterInputStream\"></a>3.FilterInputStream</h2><p>FilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。</p>\n<ul>\n<li><p>BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。</p>\n</li>\n<li><p>DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>\n</li>\n<li><p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n</li>\n</ul>\n<h3 id=\"3-1-结构\"><a href=\"#3-1-结构\" class=\"headerlink\" title=\"3.1 结构\"></a>3.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/filterinputstream.png\" alt=\"FilterInputStream的结构图\" title=\"FilterInputStream的结构图\">\n<h2 id=\"4-ObjectInputStream\"><a href=\"#4-ObjectInputStream\" class=\"headerlink\" title=\"4.ObjectInputStream\"></a>4.ObjectInputStream</h2><p>ObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。</p>\n<p>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。</p>\n<p>ObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">需要实现 java.io.Serializable 或 java.io.Externalizable的接口</div></pre></td></tr></table></figure>\n<h2 id=\"5-PipedInputStream\"><a href=\"#5-PipedInputStream\" class=\"headerlink\" title=\"5.PipedInputStream\"></a>5.PipedInputStream</h2><p>在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>\n"},{"title":"Java I/O 系列第一篇","_content":"## 1.前言\n讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：\n\n* 图片库\n* SharedPreferences\n\n还有一些应用场景：\n\n* 序列化与反序列化\n\n## 2.Java 的 I/O 类库的基本架构\nJava 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：\n\n* 基于字节操作的 I/O 接口：InputStream 和 OutputStream\n* 基于字符操作的 I/O 接口：Writer 和 Reader\n* 基于磁盘操作的 I/O 接口：File\n* 基于网络操作的 I/O 接口：Socket\n\n前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。\n\n### 2.1 基于字节操作的 I/O 接口\n基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。\n{% asset_img inputstream.png  InputStream 相关类层次结构%}\n\n{% asset_img outputstream.png OutputStream%}\n\n### 2.2基于字符的 I/O 操作接口\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。\n{% asset_img reader.png Reader相关类层次结构 %}\n\n{% asset_img writer.png Writer相关类层次结构 %}\n\n### 2.3 基于磁盘操作的 I/O 接口\n前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。\n\n我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。\n何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：\n{% asset_img file.jpg 从磁盘读取文件%}\n\n### 2.4基于网络操作的 I/O 接口\nSocket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。\n下图是典型的基于 Socket 的通信的场景：\n\n{% asset_img socket.jpg Socket 通信示例 %}\n\n\n主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。\n#### 建立通信链路\n当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。\n与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。\n#### 数据传输\n传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。\n当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。","source":"_posts/Java-IO.md","raw":"---\ntitle: Java I/O 系列第一篇\ncategories: Java,I/O\ntags: Java,I/O\n---\n## 1.前言\n讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：\n\n* 图片库\n* SharedPreferences\n\n还有一些应用场景：\n\n* 序列化与反序列化\n\n## 2.Java 的 I/O 类库的基本架构\nJava 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：\n\n* 基于字节操作的 I/O 接口：InputStream 和 OutputStream\n* 基于字符操作的 I/O 接口：Writer 和 Reader\n* 基于磁盘操作的 I/O 接口：File\n* 基于网络操作的 I/O 接口：Socket\n\n前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。\n\n### 2.1 基于字节操作的 I/O 接口\n基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。\n{% asset_img inputstream.png  InputStream 相关类层次结构%}\n\n{% asset_img outputstream.png OutputStream%}\n\n### 2.2基于字符的 I/O 操作接口\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。\n{% asset_img reader.png Reader相关类层次结构 %}\n\n{% asset_img writer.png Writer相关类层次结构 %}\n\n### 2.3 基于磁盘操作的 I/O 接口\n前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。\n\n我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。\n何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：\n{% asset_img file.jpg 从磁盘读取文件%}\n\n### 2.4基于网络操作的 I/O 接口\nSocket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。\n下图是典型的基于 Socket 的通信的场景：\n\n{% asset_img socket.jpg Socket 通信示例 %}\n\n\n主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。\n#### 建立通信链路\n当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。\n与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。\n#### 数据传输\n传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。\n当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。","slug":"Java-IO","published":1,"date":"2017-02-27T13:48:02.783Z","updated":"2017-02-27T13:48:02.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ovs00024u2dofxwyw7x","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：</p>\n<ul>\n<li>图片库</li>\n<li>SharedPreferences</li>\n</ul>\n<p>还有一些应用场景：</p>\n<ul>\n<li>序列化与反序列化</li>\n</ul>\n<h2 id=\"2-Java-的-I-O-类库的基本架构\"><a href=\"#2-Java-的-I-O-类库的基本架构\" class=\"headerlink\" title=\"2.Java 的 I/O 类库的基本架构\"></a>2.Java 的 I/O 类库的基本架构</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p>\n<ul>\n<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>\n<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>\n<li>基于磁盘操作的 I/O 接口：File</li>\n<li>基于网络操作的 I/O 接口：Socket</li>\n</ul>\n<p>前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。</p>\n<h3 id=\"2-1-基于字节操作的-I-O-接口\"><a href=\"#2-1-基于字节操作的-I-O-接口\" class=\"headerlink\" title=\"2.1 基于字节操作的 I/O 接口\"></a>2.1 基于字节操作的 I/O 接口</h3><p>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。<br><img src=\"/2017/02/27/Java-IO/inputstream.png\" alt=\"InputStream 相关类层次结构\" title=\"InputStream 相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/outputstream.png\" alt=\"OutputStream\" title=\"OutputStream\">\n<h3 id=\"2-2基于字符的-I-O-操作接口\"><a href=\"#2-2基于字符的-I-O-操作接口\" class=\"headerlink\" title=\"2.2基于字符的 I/O 操作接口\"></a>2.2基于字符的 I/O 操作接口</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。<br><img src=\"/2017/02/27/Java-IO/reader.png\" alt=\"Reader相关类层次结构\" title=\"Reader相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/writer.png\" alt=\"Writer相关类层次结构\" title=\"Writer相关类层次结构\">\n<h3 id=\"2-3-基于磁盘操作的-I-O-接口\"><a href=\"#2-3-基于磁盘操作的-I-O-接口\" class=\"headerlink\" title=\"2.3 基于磁盘操作的 I/O 接口\"></a>2.3 基于磁盘操作的 I/O 接口</h3><p>前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。</p>\n<p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。<br>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<p>下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：<br><img src=\"/2017/02/27/Java-IO/file.jpg\" alt=\"从磁盘读取文件\" title=\"从磁盘读取文件\"></p>\n<h3 id=\"2-4基于网络操作的-I-O-接口\"><a href=\"#2-4基于网络操作的-I-O-接口\" class=\"headerlink\" title=\"2.4基于网络操作的 I/O 接口\"></a>2.4基于网络操作的 I/O 接口</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。<br>下图是典型的基于 Socket 的通信的场景：</p>\n<img src=\"/2017/02/27/Java-IO/socket.jpg\" alt=\"Socket 通信示例\" title=\"Socket 通信示例\">\n<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>\n<h4 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h4><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。<br>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p>\n<h4 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h4><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。<br>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p>\n","excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：</p>\n<ul>\n<li>图片库</li>\n<li>SharedPreferences</li>\n</ul>\n<p>还有一些应用场景：</p>\n<ul>\n<li>序列化与反序列化</li>\n</ul>\n<h2 id=\"2-Java-的-I-O-类库的基本架构\"><a href=\"#2-Java-的-I-O-类库的基本架构\" class=\"headerlink\" title=\"2.Java 的 I/O 类库的基本架构\"></a>2.Java 的 I/O 类库的基本架构</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p>\n<ul>\n<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>\n<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>\n<li>基于磁盘操作的 I/O 接口：File</li>\n<li>基于网络操作的 I/O 接口：Socket</li>\n</ul>\n<p>前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。</p>\n<h3 id=\"2-1-基于字节操作的-I-O-接口\"><a href=\"#2-1-基于字节操作的-I-O-接口\" class=\"headerlink\" title=\"2.1 基于字节操作的 I/O 接口\"></a>2.1 基于字节操作的 I/O 接口</h3><p>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。<br><img src=\"/2017/02/27/Java-IO/inputstream.png\" alt=\"InputStream 相关类层次结构\" title=\"InputStream 相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/outputstream.png\" alt=\"OutputStream\" title=\"OutputStream\">\n<h3 id=\"2-2基于字符的-I-O-操作接口\"><a href=\"#2-2基于字符的-I-O-操作接口\" class=\"headerlink\" title=\"2.2基于字符的 I/O 操作接口\"></a>2.2基于字符的 I/O 操作接口</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。<br><img src=\"/2017/02/27/Java-IO/reader.png\" alt=\"Reader相关类层次结构\" title=\"Reader相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/writer.png\" alt=\"Writer相关类层次结构\" title=\"Writer相关类层次结构\">\n<h3 id=\"2-3-基于磁盘操作的-I-O-接口\"><a href=\"#2-3-基于磁盘操作的-I-O-接口\" class=\"headerlink\" title=\"2.3 基于磁盘操作的 I/O 接口\"></a>2.3 基于磁盘操作的 I/O 接口</h3><p>前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。</p>\n<p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。<br>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<p>下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：<br><img src=\"/2017/02/27/Java-IO/file.jpg\" alt=\"从磁盘读取文件\" title=\"从磁盘读取文件\"></p>\n<h3 id=\"2-4基于网络操作的-I-O-接口\"><a href=\"#2-4基于网络操作的-I-O-接口\" class=\"headerlink\" title=\"2.4基于网络操作的 I/O 接口\"></a>2.4基于网络操作的 I/O 接口</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。<br>下图是典型的基于 Socket 的通信的场景：</p>\n<img src=\"/2017/02/27/Java-IO/socket.jpg\" alt=\"Socket 通信示例\" title=\"Socket 通信示例\">\n<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>\n<h4 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h4><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。<br>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p>\n<h4 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h4><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。<br>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p>\n"},{"title":"TensorFlow","_content":"\n本篇讲一讲TensorFlow如何集成在Android上使用\n## TensorFlow在Android上的应用","source":"_posts/TensorFlow.md","raw":"---\ntitle: TensorFlow\ncategories: TensorFlow,Android\ntags: TensorFlow,Android\n---\n\n本篇讲一讲TensorFlow如何集成在Android上使用\n## TensorFlow在Android上的应用","slug":"TensorFlow","published":1,"date":"2017-02-26T09:21:31.052Z","updated":"2017-02-26T09:21:31.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ovw00054u2d10d1dhgo","content":"<p>本篇讲一讲TensorFlow如何集成在Android上使用</p>\n<h2 id=\"TensorFlow在Android上的应用\"><a href=\"#TensorFlow在Android上的应用\" class=\"headerlink\" title=\"TensorFlow在Android上的应用\"></a>TensorFlow在Android上的应用</h2>","excerpt":"","more":"<p>本篇讲一讲TensorFlow如何集成在Android上使用</p>\n<h2 id=\"TensorFlow在Android上的应用\"><a href=\"#TensorFlow在Android上的应用\" class=\"headerlink\" title=\"TensorFlow在Android上的应用\"></a>TensorFlow在Android上的应用</h2>"},{"title":"Ubuntu下设置环境变量的几种方法和区别","_content":" 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。\n## 1.通过文件设置Ubuntu环境变量\n首先是设置全局环境变量，对所有用户都会生效：\n\n* etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。\n* /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。\n\n接着是与上述两个文件对应，但只对单个用户生效：\n\n* ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。\n* ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。\n\n此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：\n\n* 系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）\n* /etc/environment 中不能包含命令，即直接通过 VAR=\"...\" 的方式设置，不使用 export 。\n* 使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。\n\n## 2.通过 Shell 命令 export 修改 Linux 环境变量\n另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：\n```\n$ export PATH=$PATH:/usr/local/hadoop/bin\n\nexport 方式只对当前终端 Shell 有效\n使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。\n```\n\n","source":"_posts/Ubuntun-set-environment.md","raw":"---\ntitle: Ubuntu下设置环境变量的几种方法和区别\ncategories: Ubuntu\ntags: Ubuntu\n---\n 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。\n## 1.通过文件设置Ubuntu环境变量\n首先是设置全局环境变量，对所有用户都会生效：\n\n* etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。\n* /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。\n\n接着是与上述两个文件对应，但只对单个用户生效：\n\n* ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。\n* ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。\n\n此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：\n\n* 系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）\n* /etc/environment 中不能包含命令，即直接通过 VAR=\"...\" 的方式设置，不使用 export 。\n* 使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。\n\n## 2.通过 Shell 命令 export 修改 Linux 环境变量\n另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：\n```\n$ export PATH=$PATH:/usr/local/hadoop/bin\n\nexport 方式只对当前终端 Shell 有效\n使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。\n```\n\n","slug":"Ubuntun-set-environment","published":1,"date":"2017-02-26T08:38:02.343Z","updated":"2017-02-26T08:38:02.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ovz00064u2d7o2e2t4u","content":"<p> 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。</p>\n<h2 id=\"1-通过文件设置Ubuntu环境变量\"><a href=\"#1-通过文件设置Ubuntu环境变量\" class=\"headerlink\" title=\"1.通过文件设置Ubuntu环境变量\"></a>1.通过文件设置Ubuntu环境变量</h2><p>首先是设置全局环境变量，对所有用户都会生效：</p>\n<ul>\n<li>etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。</li>\n<li>/etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。</li>\n</ul>\n<p>接着是与上述两个文件对应，但只对单个用户生效：</p>\n<ul>\n<li>~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。</li>\n<li>~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。</li>\n</ul>\n<p>此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：</p>\n<ul>\n<li>系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）</li>\n<li>/etc/environment 中不能包含命令，即直接通过 VAR=”…” 的方式设置，不使用 export 。</li>\n<li>使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。</li>\n</ul>\n<h2 id=\"2-通过-Shell-命令-export-修改-Linux-环境变量\"><a href=\"#2-通过-Shell-命令-export-修改-Linux-环境变量\" class=\"headerlink\" title=\"2.通过 Shell 命令 export 修改 Linux 环境变量\"></a>2.通过 Shell 命令 export 修改 Linux 环境变量</h2><p>另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ export PATH=$PATH:/usr/local/hadoop/bin</div><div class=\"line\"></div><div class=\"line\">export 方式只对当前终端 Shell 有效</div><div class=\"line\">使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p> 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。</p>\n<h2 id=\"1-通过文件设置Ubuntu环境变量\"><a href=\"#1-通过文件设置Ubuntu环境变量\" class=\"headerlink\" title=\"1.通过文件设置Ubuntu环境变量\"></a>1.通过文件设置Ubuntu环境变量</h2><p>首先是设置全局环境变量，对所有用户都会生效：</p>\n<ul>\n<li>etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。</li>\n<li>/etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。</li>\n</ul>\n<p>接着是与上述两个文件对应，但只对单个用户生效：</p>\n<ul>\n<li>~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。</li>\n<li>~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。</li>\n</ul>\n<p>此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：</p>\n<ul>\n<li>系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）</li>\n<li>/etc/environment 中不能包含命令，即直接通过 VAR=”…” 的方式设置，不使用 export 。</li>\n<li>使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。</li>\n</ul>\n<h2 id=\"2-通过-Shell-命令-export-修改-Linux-环境变量\"><a href=\"#2-通过-Shell-命令-export-修改-Linux-环境变量\" class=\"headerlink\" title=\"2.通过 Shell 命令 export 修改 Linux 环境变量\"></a>2.通过 Shell 命令 export 修改 Linux 环境变量</h2><p>另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ export PATH=$PATH:/usr/local/hadoop/bin</div><div class=\"line\"></div><div class=\"line\">export 方式只对当前终端 Shell 有效</div><div class=\"line\">使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。</div></pre></td></tr></table></figure></p>\n"},{"title":"Android在Ubuntu上配置NDK的环境","_content":"由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。\n## 1.下载Android NDK压缩包\n[官网下载](https://developer.android.com/ndk/downloads/index.html)\nNDK有不同的版本，这里根据需要下载不同的版本。\n## 2.解压\n把第1部下载的压缩包解压，我这里存放的目录如下：\n```\n/home/kl/android-sdk-linux/android-nkd-r13b\n```\n## 3. 设置环境变量\n执行如下命令\n```\n$ sudo vim ~/.bashrc\n```\n然后经如下几句加进去：\n```\nexport ANDROID_HOME=\"/home/kl/android-sdk-linux\"\nexport PATH=\"$PATH:$ANDROID_NDK\"\n```\n关闭terminal，在打开就设置成功了，在验证一下是否成功：\n```\n$ ndk-build -v\nGNU Make 3.81\nCopyright (C) 2006  Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for x86_64-pc-linux-gnu\n```","source":"_posts/Ubuntu-Android-NDK.md","raw":"---\ntitle: Android在Ubuntu上配置NDK的环境\ncategories: Android\ntags: Ubuntu,Android\n---\n由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。\n## 1.下载Android NDK压缩包\n[官网下载](https://developer.android.com/ndk/downloads/index.html)\nNDK有不同的版本，这里根据需要下载不同的版本。\n## 2.解压\n把第1部下载的压缩包解压，我这里存放的目录如下：\n```\n/home/kl/android-sdk-linux/android-nkd-r13b\n```\n## 3. 设置环境变量\n执行如下命令\n```\n$ sudo vim ~/.bashrc\n```\n然后经如下几句加进去：\n```\nexport ANDROID_HOME=\"/home/kl/android-sdk-linux\"\nexport PATH=\"$PATH:$ANDROID_NDK\"\n```\n关闭terminal，在打开就设置成功了，在验证一下是否成功：\n```\n$ ndk-build -v\nGNU Make 3.81\nCopyright (C) 2006  Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for x86_64-pc-linux-gnu\n```","slug":"Ubuntu-Android-NDK","published":1,"date":"2017-02-26T09:11:22.469Z","updated":"2017-02-26T09:11:22.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ow200074u2dqvb9jci0","content":"<p>由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。</p>\n<h2 id=\"1-下载Android-NDK压缩包\"><a href=\"#1-下载Android-NDK压缩包\" class=\"headerlink\" title=\"1.下载Android NDK压缩包\"></a>1.下载Android NDK压缩包</h2><p><a href=\"https://developer.android.com/ndk/downloads/index.html\" target=\"_blank\" rel=\"external\">官网下载</a><br>NDK有不同的版本，这里根据需要下载不同的版本。</p>\n<h2 id=\"2-解压\"><a href=\"#2-解压\" class=\"headerlink\" title=\"2.解压\"></a>2.解压</h2><p>把第1部下载的压缩包解压，我这里存放的目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/home/kl/android-sdk-linux/android-nkd-r13b</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-设置环境变量\"><a href=\"#3-设置环境变量\" class=\"headerlink\" title=\"3. 设置环境变量\"></a>3. 设置环境变量</h2><p>执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo vim ~/.bashrc</div></pre></td></tr></table></figure></p>\n<p>然后经如下几句加进去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export ANDROID_HOME=&quot;/home/kl/android-sdk-linux&quot;</div><div class=\"line\">export PATH=&quot;$PATH:$ANDROID_NDK&quot;</div></pre></td></tr></table></figure></p>\n<p>关闭terminal，在打开就设置成功了，在验证一下是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ndk-build -v</div><div class=\"line\">GNU Make 3.81</div><div class=\"line\">Copyright (C) 2006  Free Software Foundation, Inc.</div><div class=\"line\">This is free software; see the source for copying conditions.</div><div class=\"line\">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</div><div class=\"line\">PARTICULAR PURPOSE.</div><div class=\"line\"></div><div class=\"line\">This program built for x86_64-pc-linux-gnu</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。</p>\n<h2 id=\"1-下载Android-NDK压缩包\"><a href=\"#1-下载Android-NDK压缩包\" class=\"headerlink\" title=\"1.下载Android NDK压缩包\"></a>1.下载Android NDK压缩包</h2><p><a href=\"https://developer.android.com/ndk/downloads/index.html\">官网下载</a><br>NDK有不同的版本，这里根据需要下载不同的版本。</p>\n<h2 id=\"2-解压\"><a href=\"#2-解压\" class=\"headerlink\" title=\"2.解压\"></a>2.解压</h2><p>把第1部下载的压缩包解压，我这里存放的目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/home/kl/android-sdk-linux/android-nkd-r13b</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-设置环境变量\"><a href=\"#3-设置环境变量\" class=\"headerlink\" title=\"3. 设置环境变量\"></a>3. 设置环境变量</h2><p>执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo vim ~/.bashrc</div></pre></td></tr></table></figure></p>\n<p>然后经如下几句加进去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export ANDROID_HOME=&quot;/home/kl/android-sdk-linux&quot;</div><div class=\"line\">export PATH=&quot;$PATH:$ANDROID_NDK&quot;</div></pre></td></tr></table></figure></p>\n<p>关闭terminal，在打开就设置成功了，在验证一下是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ndk-build -v</div><div class=\"line\">GNU Make 3.81</div><div class=\"line\">Copyright (C) 2006  Free Software Foundation, Inc.</div><div class=\"line\">This is free software; see the source for copying conditions.</div><div class=\"line\">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</div><div class=\"line\">PARTICULAR PURPOSE.</div><div class=\"line\"></div><div class=\"line\">This program built for x86_64-pc-linux-gnu</div></pre></td></tr></table></figure></p>\n"},{"title":"一个步骤教你调试Android系统源代码","_content":"有时候我们为了搞懂Android系统组件的运行原理，需要查看系统的源代码，但是如果我们不仅能看源码，要是还能调试，岂不是更好更方便。\n\n所以，我们就说下如何调试系统源代码。其实很简单的了。\n\n#### 1.确认自己手机的API Level\n这个很简单了，就是确定自己手机系统的版本号，然后下载对应的源码，如果手机系统的版本和源码的版本对不上，那么debug的时候很容易出现对应不上代码行数的问题，因为每个版本的源码都可能有更新。\n\n#### 2.用Android Studio自带的SDK Manager下载对应版本的源码\n\"Tools\" --> \"Android\" --> \"SDK Manager\"\n如下图：\n\n{% asset_img sdk_manager.png SDK Manager%}\n\n* 注意\n```\n1. 右下角的 \"Show Package Details\" 请勾选上\n2. 在Android 7.1.1 (Nougat)下面有一个选项 \"Sources For Android 25\" ，这个就是我们要下载的源码，请选中下载\n```\n\n#### 3.还有最重要的一点，compileSdkVersion\ncompileSdkVersion,是用来告诉Gradle用哪个Android  SDK版本来编译APK，所以这里的compileSdkVersion也必须和第一步中你手机的API Level保持一致，否则，你在IDE上用到的Android SDK的源码和你的手机系统的版本不一致，就会出现调试的代码行数对不上的问题。\n\n这里还有一点说明一下，当你查看源码的时候，有这样一个路径，如下图：\n\n{% asset_img right.png android-25 viewGroup的源码 %}\n这里我们的compileSdkVersion是25,所以查看的源码路径上是/android-sdk-linux/sources/`android-25`，注意这里的android-25，而且ViewGroup.java显示的也是普通java文件的样子，现在给一个错误的例子，我们选择android-23的ViewGroup.java，显示的却是下图：\n{% asset_img error.png android-23 viewGroup的源码 %}\n很容易看到不同的地发\n\n#### 4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了\n这里和我们调试普通代码就是一样的了。经过上面的操作，Android源码就像我们添加的一个库一样。\n\n#### 补充\n刚开始我是用Nexus 6P来调试的，因为是谷歌的亲儿子，后来用同样的方法试了华为的手机，发现也可以，所以虽然一些第三方ROM有很多更改的地方，但对一些基本的FrameWork应该是没啥改动的，改的更多的应该是桌面啊这些，但这些已经属于Application层了，现在给张Android 体系结构图。\n\n{% asset_img android.jpg Android 体系结构图 %}","source":"_posts/debug-android-source.md","raw":"---\ntitle: 一个步骤教你调试Android系统源代码\ncategories: Android\ntags: Android\n---\n有时候我们为了搞懂Android系统组件的运行原理，需要查看系统的源代码，但是如果我们不仅能看源码，要是还能调试，岂不是更好更方便。\n\n所以，我们就说下如何调试系统源代码。其实很简单的了。\n\n#### 1.确认自己手机的API Level\n这个很简单了，就是确定自己手机系统的版本号，然后下载对应的源码，如果手机系统的版本和源码的版本对不上，那么debug的时候很容易出现对应不上代码行数的问题，因为每个版本的源码都可能有更新。\n\n#### 2.用Android Studio自带的SDK Manager下载对应版本的源码\n\"Tools\" --> \"Android\" --> \"SDK Manager\"\n如下图：\n\n{% asset_img sdk_manager.png SDK Manager%}\n\n* 注意\n```\n1. 右下角的 \"Show Package Details\" 请勾选上\n2. 在Android 7.1.1 (Nougat)下面有一个选项 \"Sources For Android 25\" ，这个就是我们要下载的源码，请选中下载\n```\n\n#### 3.还有最重要的一点，compileSdkVersion\ncompileSdkVersion,是用来告诉Gradle用哪个Android  SDK版本来编译APK，所以这里的compileSdkVersion也必须和第一步中你手机的API Level保持一致，否则，你在IDE上用到的Android SDK的源码和你的手机系统的版本不一致，就会出现调试的代码行数对不上的问题。\n\n这里还有一点说明一下，当你查看源码的时候，有这样一个路径，如下图：\n\n{% asset_img right.png android-25 viewGroup的源码 %}\n这里我们的compileSdkVersion是25,所以查看的源码路径上是/android-sdk-linux/sources/`android-25`，注意这里的android-25，而且ViewGroup.java显示的也是普通java文件的样子，现在给一个错误的例子，我们选择android-23的ViewGroup.java，显示的却是下图：\n{% asset_img error.png android-23 viewGroup的源码 %}\n很容易看到不同的地发\n\n#### 4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了\n这里和我们调试普通代码就是一样的了。经过上面的操作，Android源码就像我们添加的一个库一样。\n\n#### 补充\n刚开始我是用Nexus 6P来调试的，因为是谷歌的亲儿子，后来用同样的方法试了华为的手机，发现也可以，所以虽然一些第三方ROM有很多更改的地方，但对一些基本的FrameWork应该是没啥改动的，改的更多的应该是桌面啊这些，但这些已经属于Application层了，现在给张Android 体系结构图。\n\n{% asset_img android.jpg Android 体系结构图 %}","slug":"debug-android-source","published":1,"date":"2017-03-13T12:40:55.011Z","updated":"2017-03-13T12:40:55.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0ow5000b4u2dyqb3lyq1","content":"<p>有时候我们为了搞懂Android系统组件的运行原理，需要查看系统的源代码，但是如果我们不仅能看源码，要是还能调试，岂不是更好更方便。</p>\n<p>所以，我们就说下如何调试系统源代码。其实很简单的了。</p>\n<h4 id=\"1-确认自己手机的API-Level\"><a href=\"#1-确认自己手机的API-Level\" class=\"headerlink\" title=\"1.确认自己手机的API Level\"></a>1.确认自己手机的API Level</h4><p>这个很简单了，就是确定自己手机系统的版本号，然后下载对应的源码，如果手机系统的版本和源码的版本对不上，那么debug的时候很容易出现对应不上代码行数的问题，因为每个版本的源码都可能有更新。</p>\n<h4 id=\"2-用Android-Studio自带的SDK-Manager下载对应版本的源码\"><a href=\"#2-用Android-Studio自带的SDK-Manager下载对应版本的源码\" class=\"headerlink\" title=\"2.用Android Studio自带的SDK Manager下载对应版本的源码\"></a>2.用Android Studio自带的SDK Manager下载对应版本的源码</h4><p>“Tools” –&gt; “Android” –&gt; “SDK Manager”<br>如下图：</p>\n<img src=\"/2017/03/13/debug-android-source/sdk_manager.png\" alt=\"SDK Manager\" title=\"SDK Manager\">\n<ul>\n<li>注意<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 右下角的 &quot;Show Package Details&quot; 请勾选上</div><div class=\"line\">2. 在Android 7.1.1 (Nougat)下面有一个选项 &quot;Sources For Android 25&quot; ，这个就是我们要下载的源码，请选中下载</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-还有最重要的一点，compileSdkVersion\"><a href=\"#3-还有最重要的一点，compileSdkVersion\" class=\"headerlink\" title=\"3.还有最重要的一点，compileSdkVersion\"></a>3.还有最重要的一点，compileSdkVersion</h4><p>compileSdkVersion,是用来告诉Gradle用哪个Android  SDK版本来编译APK，所以这里的compileSdkVersion也必须和第一步中你手机的API Level保持一致，否则，你在IDE上用到的Android SDK的源码和你的手机系统的版本不一致，就会出现调试的代码行数对不上的问题。</p>\n<p>这里还有一点说明一下，当你查看源码的时候，有这样一个路径，如下图：</p>\n<img src=\"/2017/03/13/debug-android-source/right.png\" alt=\"android-25 viewGroup的源码\" title=\"android-25 viewGroup的源码\">\n<p>这里我们的compileSdkVersion是25,所以查看的源码路径上是/android-sdk-linux/sources/<code>android-25</code>，注意这里的android-25，而且ViewGroup.java显示的也是普通java文件的样子，现在给一个错误的例子，我们选择android-23的ViewGroup.java，显示的却是下图：<br><img src=\"/2017/03/13/debug-android-source/error.png\" alt=\"android-23 viewGroup的源码\" title=\"android-23 viewGroup的源码\"><br>很容易看到不同的地发</p>\n<h4 id=\"4-最后一部，加上断点，attach上进程，就可以愉快的调试源码了\"><a href=\"#4-最后一部，加上断点，attach上进程，就可以愉快的调试源码了\" class=\"headerlink\" title=\"4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了\"></a>4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了</h4><p>这里和我们调试普通代码就是一样的了。经过上面的操作，Android源码就像我们添加的一个库一样。</p>\n<h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h4><p>刚开始我是用Nexus 6P来调试的，因为是谷歌的亲儿子，后来用同样的方法试了华为的手机，发现也可以，所以虽然一些第三方ROM有很多更改的地方，但对一些基本的FrameWork应该是没啥改动的，改的更多的应该是桌面啊这些，但这些已经属于Application层了，现在给张Android 体系结构图。</p>\n<img src=\"/2017/03/13/debug-android-source/android.jpg\" alt=\"Android 体系结构图\" title=\"Android 体系结构图\">","excerpt":"","more":"<p>有时候我们为了搞懂Android系统组件的运行原理，需要查看系统的源代码，但是如果我们不仅能看源码，要是还能调试，岂不是更好更方便。</p>\n<p>所以，我们就说下如何调试系统源代码。其实很简单的了。</p>\n<h4 id=\"1-确认自己手机的API-Level\"><a href=\"#1-确认自己手机的API-Level\" class=\"headerlink\" title=\"1.确认自己手机的API Level\"></a>1.确认自己手机的API Level</h4><p>这个很简单了，就是确定自己手机系统的版本号，然后下载对应的源码，如果手机系统的版本和源码的版本对不上，那么debug的时候很容易出现对应不上代码行数的问题，因为每个版本的源码都可能有更新。</p>\n<h4 id=\"2-用Android-Studio自带的SDK-Manager下载对应版本的源码\"><a href=\"#2-用Android-Studio自带的SDK-Manager下载对应版本的源码\" class=\"headerlink\" title=\"2.用Android Studio自带的SDK Manager下载对应版本的源码\"></a>2.用Android Studio自带的SDK Manager下载对应版本的源码</h4><p>“Tools” –&gt; “Android” –&gt; “SDK Manager”<br>如下图：</p>\n<img src=\"/2017/03/13/debug-android-source/sdk_manager.png\" alt=\"SDK Manager\" title=\"SDK Manager\">\n<ul>\n<li>注意<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 右下角的 &quot;Show Package Details&quot; 请勾选上</div><div class=\"line\">2. 在Android 7.1.1 (Nougat)下面有一个选项 &quot;Sources For Android 25&quot; ，这个就是我们要下载的源码，请选中下载</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-还有最重要的一点，compileSdkVersion\"><a href=\"#3-还有最重要的一点，compileSdkVersion\" class=\"headerlink\" title=\"3.还有最重要的一点，compileSdkVersion\"></a>3.还有最重要的一点，compileSdkVersion</h4><p>compileSdkVersion,是用来告诉Gradle用哪个Android  SDK版本来编译APK，所以这里的compileSdkVersion也必须和第一步中你手机的API Level保持一致，否则，你在IDE上用到的Android SDK的源码和你的手机系统的版本不一致，就会出现调试的代码行数对不上的问题。</p>\n<p>这里还有一点说明一下，当你查看源码的时候，有这样一个路径，如下图：</p>\n<img src=\"/2017/03/13/debug-android-source/right.png\" alt=\"android-25 viewGroup的源码\" title=\"android-25 viewGroup的源码\">\n<p>这里我们的compileSdkVersion是25,所以查看的源码路径上是/android-sdk-linux/sources/<code>android-25</code>，注意这里的android-25，而且ViewGroup.java显示的也是普通java文件的样子，现在给一个错误的例子，我们选择android-23的ViewGroup.java，显示的却是下图：<br><img src=\"/2017/03/13/debug-android-source/error.png\" alt=\"android-23 viewGroup的源码\" title=\"android-23 viewGroup的源码\"><br>很容易看到不同的地发</p>\n<h4 id=\"4-最后一部，加上断点，attach上进程，就可以愉快的调试源码了\"><a href=\"#4-最后一部，加上断点，attach上进程，就可以愉快的调试源码了\" class=\"headerlink\" title=\"4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了\"></a>4.最后一部，加上断点，attach上进程，就可以愉快的调试源码了</h4><p>这里和我们调试普通代码就是一样的了。经过上面的操作，Android源码就像我们添加的一个库一样。</p>\n<h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h4><p>刚开始我是用Nexus 6P来调试的，因为是谷歌的亲儿子，后来用同样的方法试了华为的手机，发现也可以，所以虽然一些第三方ROM有很多更改的地方，但对一些基本的FrameWork应该是没啥改动的，改的更多的应该是桌面啊这些，但这些已经属于Application层了，现在给张Android 体系结构图。</p>\n<img src=\"/2017/03/13/debug-android-source/android.jpg\" alt=\"Android 体系结构图\" title=\"Android 体系结构图\">"},{"title":"为什么使用git","_content":"\n## SVN与GIT的区别\n* 概念\n   SVN:集中化的版本控制系统\n   GIT:分布式版本控制系统\n```\n集中化的系统，受限于服务器，比如：提交记录，如果我离线的话，提交记录是看不到的；代码更改，我想查看每次提交的更改也很困难；\n```\n* 文件记录方式\n    SVN:记录每个文件的变化，每个版本存储前后变化的差异数据\n    GIT:记录整体数据的变化，每次提交，把所有文件生成一个快照，和前面一次提交对比，若文件没变化，直接指向上一次文件，只记录变化的文件\n\n* 分支的创建和合并\n   SVN:每次分支都是对之前代码重新拷贝到一个新目录\n   GIT:分支的创建和合并代价很小，十分方便\n\n ```\n 很明显的一个地方是文件的大小，SVN有几个分支，大小就增加几倍，而git使用指针记录每次提交的，分支的创建和合并其实就是对指针的操作，效率可见一斑\n ```\n\n## 对GIT的一些误区\n\n* git≠github\n```\ngit是分布式的版本控制系统\ngithub是一个托管git库的网站，使用git作为代码版本管理工具,github是全球最大的代码开源网站，上面的大部分git库都是公开(public)的，就是所有人都可以访问，也有私有库(private),只有拥有权限的人才可以访问\ngitlab是一个用于仓库管理系统的开源项目，可以理解成和github是一样的，提供web界面管理git仓库，但是可以搭建在私有服务器上，保证代码安全\n```\n\n* git不慢\n\n```\n感觉大部分人都觉的git很慢，这是一个很大的误区，可能是大部分人刚开始都是通过github接触git的，github的服务器在国外，而且我大天朝的网络环境，大家都懂的，其实从上面对git和svn实现原理的比较，显然git比svn快，如果我们都用内网的git服务，就不会感觉git慢了\n```\n* 觉得git麻烦\n\n```\n可能是大部分人一接触git，需要一大堆配置就觉得麻烦，所以要给大家讲明白为什么需要这些配置，git使用的ssh协议(http也支持)，ssh通过公私玥来加密数据，所以一开始会让大家生成一个公钥并上传到网站上，为了标明每次commit是谁提交的，会配置开发者的一些基本信息\n```\n\n* git和svn一样简单易上手\n\n```\n为什么这么说呢，因为从本质上来说，都是版本管理系统，我们从常用的几个操作来说:\n\n```\n| 操作 | svn | git |\n| -- | -- | -- |\n| 从服务器拉工程 | check out | clone |\n| 提交 | commit | commit->push |\n| 更新 | update | pull |\n\n```\n可以发现步骤基本是一样的\n```\n\n[ssh详解](https://zh.wikipedia.org/wiki/Secure_Shell)\n[公开密钥加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)\n\n## 为什么使用GIT?\n  * 为了装逼？\n  * 因为别人用，所以我们也用？\n\n  肯定不是这些原因，使用git是为了:\n\n  * 提高开发效率!\n\n  ```\n   git不仅仅是一个代码版本管理工具，也是一个文档管理工具，在git上很容易维护一个文档\n  ```\n\n git可以提高开发效率，主要表现在:\n\n * 合并对提交过程的保留\n * 修正提交\n * 廉价好用的本地分支\n * 更强大智能的合并能力\n * 完整配套的开发过程设施(wiki issue 功能大赞！)\n * 查看日志","source":"_posts/git.md","raw":"---\ntitle: 为什么使用git\ncategories: git\ntags: git \n---\n\n## SVN与GIT的区别\n* 概念\n   SVN:集中化的版本控制系统\n   GIT:分布式版本控制系统\n```\n集中化的系统，受限于服务器，比如：提交记录，如果我离线的话，提交记录是看不到的；代码更改，我想查看每次提交的更改也很困难；\n```\n* 文件记录方式\n    SVN:记录每个文件的变化，每个版本存储前后变化的差异数据\n    GIT:记录整体数据的变化，每次提交，把所有文件生成一个快照，和前面一次提交对比，若文件没变化，直接指向上一次文件，只记录变化的文件\n\n* 分支的创建和合并\n   SVN:每次分支都是对之前代码重新拷贝到一个新目录\n   GIT:分支的创建和合并代价很小，十分方便\n\n ```\n 很明显的一个地方是文件的大小，SVN有几个分支，大小就增加几倍，而git使用指针记录每次提交的，分支的创建和合并其实就是对指针的操作，效率可见一斑\n ```\n\n## 对GIT的一些误区\n\n* git≠github\n```\ngit是分布式的版本控制系统\ngithub是一个托管git库的网站，使用git作为代码版本管理工具,github是全球最大的代码开源网站，上面的大部分git库都是公开(public)的，就是所有人都可以访问，也有私有库(private),只有拥有权限的人才可以访问\ngitlab是一个用于仓库管理系统的开源项目，可以理解成和github是一样的，提供web界面管理git仓库，但是可以搭建在私有服务器上，保证代码安全\n```\n\n* git不慢\n\n```\n感觉大部分人都觉的git很慢，这是一个很大的误区，可能是大部分人刚开始都是通过github接触git的，github的服务器在国外，而且我大天朝的网络环境，大家都懂的，其实从上面对git和svn实现原理的比较，显然git比svn快，如果我们都用内网的git服务，就不会感觉git慢了\n```\n* 觉得git麻烦\n\n```\n可能是大部分人一接触git，需要一大堆配置就觉得麻烦，所以要给大家讲明白为什么需要这些配置，git使用的ssh协议(http也支持)，ssh通过公私玥来加密数据，所以一开始会让大家生成一个公钥并上传到网站上，为了标明每次commit是谁提交的，会配置开发者的一些基本信息\n```\n\n* git和svn一样简单易上手\n\n```\n为什么这么说呢，因为从本质上来说，都是版本管理系统，我们从常用的几个操作来说:\n\n```\n| 操作 | svn | git |\n| -- | -- | -- |\n| 从服务器拉工程 | check out | clone |\n| 提交 | commit | commit->push |\n| 更新 | update | pull |\n\n```\n可以发现步骤基本是一样的\n```\n\n[ssh详解](https://zh.wikipedia.org/wiki/Secure_Shell)\n[公开密钥加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)\n\n## 为什么使用GIT?\n  * 为了装逼？\n  * 因为别人用，所以我们也用？\n\n  肯定不是这些原因，使用git是为了:\n\n  * 提高开发效率!\n\n  ```\n   git不仅仅是一个代码版本管理工具，也是一个文档管理工具，在git上很容易维护一个文档\n  ```\n\n git可以提高开发效率，主要表现在:\n\n * 合并对提交过程的保留\n * 修正提交\n * 廉价好用的本地分支\n * 更强大智能的合并能力\n * 完整配套的开发过程设施(wiki issue 功能大赞！)\n * 查看日志","slug":"git","published":1,"date":"2017-03-30T13:07:28.570Z","updated":"2017-03-30T13:07:28.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0owa000d4u2dk39gcd0x","content":"<h2 id=\"SVN与GIT的区别\"><a href=\"#SVN与GIT的区别\" class=\"headerlink\" title=\"SVN与GIT的区别\"></a>SVN与GIT的区别</h2><ul>\n<li><p>概念<br> SVN:集中化的版本控制系统<br> GIT:分布式版本控制系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">集中化的系统，受限于服务器，比如：提交记录，如果我离线的话，提交记录是看不到的；代码更改，我想查看每次提交的更改也很困难；</div></pre></td></tr></table></figure>\n</li>\n<li><p>文件记录方式<br>  SVN:记录每个文件的变化，每个版本存储前后变化的差异数据<br>  GIT:记录整体数据的变化，每次提交，把所有文件生成一个快照，和前面一次提交对比，若文件没变化，直接指向上一次文件，只记录变化的文件</p>\n</li>\n<li><p>分支的创建和合并<br> SVN:每次分支都是对之前代码重新拷贝到一个新目录<br> GIT:分支的创建和合并代价很小，十分方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">很明显的一个地方是文件的大小，SVN有几个分支，大小就增加几倍，而git使用指针记录每次提交的，分支的创建和合并其实就是对指针的操作，效率可见一斑</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"对GIT的一些误区\"><a href=\"#对GIT的一些误区\" class=\"headerlink\" title=\"对GIT的一些误区\"></a>对GIT的一些误区</h2><ul>\n<li><p>git≠github</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git是分布式的版本控制系统</div><div class=\"line\">github是一个托管git库的网站，使用git作为代码版本管理工具,github是全球最大的代码开源网站，上面的大部分git库都是公开(public)的，就是所有人都可以访问，也有私有库(private),只有拥有权限的人才可以访问</div><div class=\"line\">gitlab是一个用于仓库管理系统的开源项目，可以理解成和github是一样的，提供web界面管理git仓库，但是可以搭建在私有服务器上，保证代码安全</div></pre></td></tr></table></figure>\n</li>\n<li><p>git不慢</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">感觉大部分人都觉的git很慢，这是一个很大的误区，可能是大部分人刚开始都是通过github接触git的，github的服务器在国外，而且我大天朝的网络环境，大家都懂的，其实从上面对git和svn实现原理的比较，显然git比svn快，如果我们都用内网的git服务，就不会感觉git慢了</div></pre></td></tr></table></figure>\n<ul>\n<li>觉得git麻烦</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">可能是大部分人一接触git，需要一大堆配置就觉得麻烦，所以要给大家讲明白为什么需要这些配置，git使用的ssh协议(http也支持)，ssh通过公私玥来加密数据，所以一开始会让大家生成一个公钥并上传到网站上，为了标明每次commit是谁提交的，会配置开发者的一些基本信息</div></pre></td></tr></table></figure>\n<ul>\n<li>git和svn一样简单易上手</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">为什么这么说呢，因为从本质上来说，都是版本管理系统，我们从常用的几个操作来说:</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>svn</th>\n<th>git</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从服务器拉工程</td>\n<td>check out</td>\n<td>clone</td>\n</tr>\n<tr>\n<td>提交</td>\n<td>commit</td>\n<td>commit-&gt;push</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>update</td>\n<td>pull</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">可以发现步骤基本是一样的</div></pre></td></tr></table></figure>\n<p><a href=\"https://zh.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">ssh详解</a><br><a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"external\">公开密钥加密</a></p>\n<h2 id=\"为什么使用GIT\"><a href=\"#为什么使用GIT\" class=\"headerlink\" title=\"为什么使用GIT?\"></a>为什么使用GIT?</h2><ul>\n<li>为了装逼？</li>\n<li><p>因为别人用，所以我们也用？</p>\n<p>肯定不是这些原因，使用git是为了:</p>\n</li>\n<li><p>提高开发效率!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git不仅仅是一个代码版本管理工具，也是一个文档管理工具，在git上很容易维护一个文档</div></pre></td></tr></table></figure>\n<p>git可以提高开发效率，主要表现在:</p>\n<ul>\n<li>合并对提交过程的保留</li>\n<li>修正提交</li>\n<li>廉价好用的本地分支</li>\n<li>更强大智能的合并能力</li>\n<li>完整配套的开发过程设施(wiki issue 功能大赞！)</li>\n<li>查看日志</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"SVN与GIT的区别\"><a href=\"#SVN与GIT的区别\" class=\"headerlink\" title=\"SVN与GIT的区别\"></a>SVN与GIT的区别</h2><ul>\n<li><p>概念<br> SVN:集中化的版本控制系统<br> GIT:分布式版本控制系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">集中化的系统，受限于服务器，比如：提交记录，如果我离线的话，提交记录是看不到的；代码更改，我想查看每次提交的更改也很困难；</div></pre></td></tr></table></figure>\n</li>\n<li><p>文件记录方式<br>  SVN:记录每个文件的变化，每个版本存储前后变化的差异数据<br>  GIT:记录整体数据的变化，每次提交，把所有文件生成一个快照，和前面一次提交对比，若文件没变化，直接指向上一次文件，只记录变化的文件</p>\n</li>\n<li><p>分支的创建和合并<br> SVN:每次分支都是对之前代码重新拷贝到一个新目录<br> GIT:分支的创建和合并代价很小，十分方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">很明显的一个地方是文件的大小，SVN有几个分支，大小就增加几倍，而git使用指针记录每次提交的，分支的创建和合并其实就是对指针的操作，效率可见一斑</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"对GIT的一些误区\"><a href=\"#对GIT的一些误区\" class=\"headerlink\" title=\"对GIT的一些误区\"></a>对GIT的一些误区</h2><ul>\n<li><p>git≠github</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git是分布式的版本控制系统</div><div class=\"line\">github是一个托管git库的网站，使用git作为代码版本管理工具,github是全球最大的代码开源网站，上面的大部分git库都是公开(public)的，就是所有人都可以访问，也有私有库(private),只有拥有权限的人才可以访问</div><div class=\"line\">gitlab是一个用于仓库管理系统的开源项目，可以理解成和github是一样的，提供web界面管理git仓库，但是可以搭建在私有服务器上，保证代码安全</div></pre></td></tr></table></figure>\n</li>\n<li><p>git不慢</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">感觉大部分人都觉的git很慢，这是一个很大的误区，可能是大部分人刚开始都是通过github接触git的，github的服务器在国外，而且我大天朝的网络环境，大家都懂的，其实从上面对git和svn实现原理的比较，显然git比svn快，如果我们都用内网的git服务，就不会感觉git慢了</div></pre></td></tr></table></figure>\n<ul>\n<li>觉得git麻烦</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">可能是大部分人一接触git，需要一大堆配置就觉得麻烦，所以要给大家讲明白为什么需要这些配置，git使用的ssh协议(http也支持)，ssh通过公私玥来加密数据，所以一开始会让大家生成一个公钥并上传到网站上，为了标明每次commit是谁提交的，会配置开发者的一些基本信息</div></pre></td></tr></table></figure>\n<ul>\n<li>git和svn一样简单易上手</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">为什么这么说呢，因为从本质上来说，都是版本管理系统，我们从常用的几个操作来说:</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>svn</th>\n<th>git</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>从服务器拉工程</td>\n<td>check out</td>\n<td>clone</td>\n</tr>\n<tr>\n<td>提交</td>\n<td>commit</td>\n<td>commit-&gt;push</td>\n</tr>\n<tr>\n<td>更新</td>\n<td>update</td>\n<td>pull</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">可以发现步骤基本是一样的</div></pre></td></tr></table></figure>\n<p><a href=\"https://zh.wikipedia.org/wiki/Secure_Shell\">ssh详解</a><br><a href=\"https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\">公开密钥加密</a></p>\n<h2 id=\"为什么使用GIT\"><a href=\"#为什么使用GIT\" class=\"headerlink\" title=\"为什么使用GIT?\"></a>为什么使用GIT?</h2><ul>\n<li>为了装逼？</li>\n<li><p>因为别人用，所以我们也用？</p>\n<p>肯定不是这些原因，使用git是为了:</p>\n</li>\n<li><p>提高开发效率!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git不仅仅是一个代码版本管理工具，也是一个文档管理工具，在git上很容易维护一个文档</div></pre></td></tr></table></figure>\n<p>git可以提高开发效率，主要表现在:</p>\n<ul>\n<li>合并对提交过程的保留</li>\n<li>修正提交</li>\n<li>廉价好用的本地分支</li>\n<li>更强大智能的合并能力</li>\n<li>完整配套的开发过程设施(wiki issue 功能大赞！)</li>\n<li>查看日志</li>\n</ul>\n</li>\n</ul>\n"},{"title":"用3个View实现无线循环的ViewPager","_content":"\n## 前言\n用ViewPager实现无限循环，想必大家都知道，但实现无线循环的效果，其实只需要三个view便能完成，本篇就先介绍下实现无限循环的原理，在告诉大家怎么只用三个view边实现无限循环。\n\n### LoopViewPager的原理\n下面有四个View：A、B、C、D，默认情况下我们只能从A->B->C->D或者从D->C->B->A，如下图：\n\n{% asset_img origin.png  %}\n\n每当移动到两边的view时，就没办法在滑动下去了，而要实现无限循环滑动，必须得实现这样的效果，A->B->C->D->A,或者D->C->B->-A->D,所以我们出现了方案1如下图：\n\n{% asset_img modify.png 方案一%}\n\n当在D上往左拖动的时候，就定位到A，而当A往右拖动的时候就定位到D，但是这个方案有个巨大的缺陷，当D往左拖动的时候，D的右边是没有view的，这样就不会有拖动中view的动画效果，所以这个方案pass。\n\n继续上面的思路想，那往D的右边加一个和A一样的view（我们暂时称为A'），这样当D往左拖动的时候，显示的是A'，当拖动动画结束的时候，定位到A（PS：这样里用ViewPager.setCurrentItem(A,false)来实现，因为是false，所以不会展现动画，用户就感知不到这里的变化），这里用setCurr这样就又从头开始，这个方法可行，效果图如下：\n\n{% asset_img modify2.png 方案二%}\n\n具体的实现代码请看： https://github.com/imbryk/LoopingViewPager\n这个代码就是按照方面二的思路来实现的，这里的例子给的是4个view，之后不管我们要实现多少个view的无限循环，只要我们在队首加一个最后的view，在队尾加一个第一个的view，我们都能实现无限循环。\n\n到这里就结束了？当然没有，因为我们的目标是不管你要展示多少个view，我们只用三个view就可以实现全部view的无限循环！\n\n### 三个View实现无限循环\n先看图：\n\n{% asset_img final.png 三个View实现无限循环%}\n\n我们可以看到这个方案其实和上面的方案二很像，不同的是我们用到了view的复用，而且我们给用户展现的永远是第二个view，每当用户有滑动操作的时候，我们就更新\n第二个view的数据，以此来更新试图，让用户误以为自己是在无限滑动\n\n具体的代码可以查看我的工程，欢迎star，github地址为： https://github.com/koudle/ThreeInfiniteViewPager","source":"_posts/loopviewpager.md","raw":"---\ntitle: 用3个View实现无线循环的ViewPager\ncategories: Android\ntags: Android\n---\n\n## 前言\n用ViewPager实现无限循环，想必大家都知道，但实现无线循环的效果，其实只需要三个view便能完成，本篇就先介绍下实现无限循环的原理，在告诉大家怎么只用三个view边实现无限循环。\n\n### LoopViewPager的原理\n下面有四个View：A、B、C、D，默认情况下我们只能从A->B->C->D或者从D->C->B->A，如下图：\n\n{% asset_img origin.png  %}\n\n每当移动到两边的view时，就没办法在滑动下去了，而要实现无限循环滑动，必须得实现这样的效果，A->B->C->D->A,或者D->C->B->-A->D,所以我们出现了方案1如下图：\n\n{% asset_img modify.png 方案一%}\n\n当在D上往左拖动的时候，就定位到A，而当A往右拖动的时候就定位到D，但是这个方案有个巨大的缺陷，当D往左拖动的时候，D的右边是没有view的，这样就不会有拖动中view的动画效果，所以这个方案pass。\n\n继续上面的思路想，那往D的右边加一个和A一样的view（我们暂时称为A'），这样当D往左拖动的时候，显示的是A'，当拖动动画结束的时候，定位到A（PS：这样里用ViewPager.setCurrentItem(A,false)来实现，因为是false，所以不会展现动画，用户就感知不到这里的变化），这里用setCurr这样就又从头开始，这个方法可行，效果图如下：\n\n{% asset_img modify2.png 方案二%}\n\n具体的实现代码请看： https://github.com/imbryk/LoopingViewPager\n这个代码就是按照方面二的思路来实现的，这里的例子给的是4个view，之后不管我们要实现多少个view的无限循环，只要我们在队首加一个最后的view，在队尾加一个第一个的view，我们都能实现无限循环。\n\n到这里就结束了？当然没有，因为我们的目标是不管你要展示多少个view，我们只用三个view就可以实现全部view的无限循环！\n\n### 三个View实现无限循环\n先看图：\n\n{% asset_img final.png 三个View实现无限循环%}\n\n我们可以看到这个方案其实和上面的方案二很像，不同的是我们用到了view的复用，而且我们给用户展现的永远是第二个view，每当用户有滑动操作的时候，我们就更新\n第二个view的数据，以此来更新试图，让用户误以为自己是在无限滑动\n\n具体的代码可以查看我的工程，欢迎star，github地址为： https://github.com/koudle/ThreeInfiniteViewPager","slug":"loopviewpager","published":1,"date":"2017-03-12T13:44:39.635Z","updated":"2017-03-12T13:44:39.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0owb000g4u2dvpg7pic7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用ViewPager实现无限循环，想必大家都知道，但实现无线循环的效果，其实只需要三个view便能完成，本篇就先介绍下实现无限循环的原理，在告诉大家怎么只用三个view边实现无限循环。</p>\n<h3 id=\"LoopViewPager的原理\"><a href=\"#LoopViewPager的原理\" class=\"headerlink\" title=\"LoopViewPager的原理\"></a>LoopViewPager的原理</h3><p>下面有四个View：A、B、C、D，默认情况下我们只能从A-&gt;B-&gt;C-&gt;D或者从D-&gt;C-&gt;B-&gt;A，如下图：</p>\n<img src=\"/2017/03/12/loopviewpager/origin.png\" alt=\"origin.png\" title=\"\">\n<p>每当移动到两边的view时，就没办法在滑动下去了，而要实现无限循环滑动，必须得实现这样的效果，A-&gt;B-&gt;C-&gt;D-&gt;A,或者D-&gt;C-&gt;B-&gt;-A-&gt;D,所以我们出现了方案1如下图：</p>\n\n<p>当在D上往左拖动的时候，就定位到A，而当A往右拖动的时候就定位到D，但是这个方案有个巨大的缺陷，当D往左拖动的时候，D的右边是没有view的，这样就不会有拖动中view的动画效果，所以这个方案pass。</p>\n<p>继续上面的思路想，那往D的右边加一个和A一样的view（我们暂时称为A’），这样当D往左拖动的时候，显示的是A’，当拖动动画结束的时候，定位到A（PS：这样里用ViewPager.setCurrentItem(A,false)来实现，因为是false，所以不会展现动画，用户就感知不到这里的变化），这里用setCurr这样就又从头开始，这个方法可行，效果图如下：</p>\n<img src=\"/2017/03/12/loopviewpager/modify2.png\" alt=\"方案二\" title=\"方案二\">\n<p>具体的实现代码请看： <a href=\"https://github.com/imbryk/LoopingViewPager\" target=\"_blank\" rel=\"external\">https://github.com/imbryk/LoopingViewPager</a><br>这个代码就是按照方面二的思路来实现的，这里的例子给的是4个view，之后不管我们要实现多少个view的无限循环，只要我们在队首加一个最后的view，在队尾加一个第一个的view，我们都能实现无限循环。</p>\n<p>到这里就结束了？当然没有，因为我们的目标是不管你要展示多少个view，我们只用三个view就可以实现全部view的无限循环！</p>\n<h3 id=\"三个View实现无限循环\"><a href=\"#三个View实现无限循环\" class=\"headerlink\" title=\"三个View实现无限循环\"></a>三个View实现无限循环</h3><p>先看图：</p>\n<img src=\"/2017/03/12/loopviewpager/final.png\" alt=\"三个View实现无限循环\" title=\"三个View实现无限循环\">\n<p>我们可以看到这个方案其实和上面的方案二很像，不同的是我们用到了view的复用，而且我们给用户展现的永远是第二个view，每当用户有滑动操作的时候，我们就更新<br>第二个view的数据，以此来更新试图，让用户误以为自己是在无限滑动</p>\n<p>具体的代码可以查看我的工程，欢迎star，github地址为： <a href=\"https://github.com/koudle/ThreeInfiniteViewPager\" target=\"_blank\" rel=\"external\">https://github.com/koudle/ThreeInfiniteViewPager</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>用ViewPager实现无限循环，想必大家都知道，但实现无线循环的效果，其实只需要三个view便能完成，本篇就先介绍下实现无限循环的原理，在告诉大家怎么只用三个view边实现无限循环。</p>\n<h3 id=\"LoopViewPager的原理\"><a href=\"#LoopViewPager的原理\" class=\"headerlink\" title=\"LoopViewPager的原理\"></a>LoopViewPager的原理</h3><p>下面有四个View：A、B、C、D，默认情况下我们只能从A-&gt;B-&gt;C-&gt;D或者从D-&gt;C-&gt;B-&gt;A，如下图：</p>\n<img src=\"/2017/03/12/loopviewpager/origin.png\" alt=\"origin.png\" title=\"\">\n<p>每当移动到两边的view时，就没办法在滑动下去了，而要实现无限循环滑动，必须得实现这样的效果，A-&gt;B-&gt;C-&gt;D-&gt;A,或者D-&gt;C-&gt;B-&gt;-A-&gt;D,所以我们出现了方案1如下图：</p>\n\n<p>当在D上往左拖动的时候，就定位到A，而当A往右拖动的时候就定位到D，但是这个方案有个巨大的缺陷，当D往左拖动的时候，D的右边是没有view的，这样就不会有拖动中view的动画效果，所以这个方案pass。</p>\n<p>继续上面的思路想，那往D的右边加一个和A一样的view（我们暂时称为A’），这样当D往左拖动的时候，显示的是A’，当拖动动画结束的时候，定位到A（PS：这样里用ViewPager.setCurrentItem(A,false)来实现，因为是false，所以不会展现动画，用户就感知不到这里的变化），这里用setCurr这样就又从头开始，这个方法可行，效果图如下：</p>\n<img src=\"/2017/03/12/loopviewpager/modify2.png\" alt=\"方案二\" title=\"方案二\">\n<p>具体的实现代码请看： <a href=\"https://github.com/imbryk/LoopingViewPager\">https://github.com/imbryk/LoopingViewPager</a><br>这个代码就是按照方面二的思路来实现的，这里的例子给的是4个view，之后不管我们要实现多少个view的无限循环，只要我们在队首加一个最后的view，在队尾加一个第一个的view，我们都能实现无限循环。</p>\n<p>到这里就结束了？当然没有，因为我们的目标是不管你要展示多少个view，我们只用三个view就可以实现全部view的无限循环！</p>\n<h3 id=\"三个View实现无限循环\"><a href=\"#三个View实现无限循环\" class=\"headerlink\" title=\"三个View实现无限循环\"></a>三个View实现无限循环</h3><p>先看图：</p>\n<img src=\"/2017/03/12/loopviewpager/final.png\" alt=\"三个View实现无限循环\" title=\"三个View实现无限循环\">\n<p>我们可以看到这个方案其实和上面的方案二很像，不同的是我们用到了view的复用，而且我们给用户展现的永远是第二个view，每当用户有滑动操作的时候，我们就更新<br>第二个view的数据，以此来更新试图，让用户误以为自己是在无限滑动</p>\n<p>具体的代码可以查看我的工程，欢迎star，github地址为： <a href=\"https://github.com/koudle/ThreeInfiniteViewPager\">https://github.com/koudle/ThreeInfiniteViewPager</a></p>\n"},{"title":"SharedPreferences的源码解析及优化","_content":"SharedPrenference我们都经常用，但是它的内部是如何实现的？而且在用的过程中，很容易出现性能问题，该如何优化？","source":"_posts/sharedPreferences.md","raw":"---\ntitle: SharedPreferences的源码解析及优化\ncategories: Android\ntags: Android\n---\nSharedPrenference我们都经常用，但是它的内部是如何实现的？而且在用的过程中，很容易出现性能问题，该如何优化？","slug":"sharedPreferences","published":1,"date":"2017-03-15T13:42:09.321Z","updated":"2017-03-15T13:42:09.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0owf000i4u2d95y491h3","content":"<p>SharedPrenference我们都经常用，但是它的内部是如何实现的？而且在用的过程中，很容易出现性能问题，该如何优化？</p>\n","excerpt":"","more":"<p>SharedPrenference我们都经常用，但是它的内部是如何实现的？而且在用的过程中，很容易出现性能问题，该如何优化？</p>\n"},{"title":"需不需要手动调用System.gc()","_content":"## 导语\n曾几何时，我们一直纠结于到底要不要手动调用System.gc()，有的人说这样调用太丑陋，完全没必要，JVM会帮我们处理好的，有的人说可以调用，这样可以及时释放内存，现在可以明确的告诉你，在Android5.0及以上手动调用System.gc()完全没必要，因为你调了也完全触发不了gc，为什么会这样说呢？\n\n`Talk is cheap,show you the code`\n\n我们直接看代码!\n\n\n## 源码\n\n### Android5.0之前的代码\n\n如下:\n\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\t\n这个看上去完全没问题\n\n### Android 5.0及以后的代码\n\n先看System.gc()到底做了什么，如下:\n\n\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n\n\n简单易懂啊，前面就是一些赋值啊判断啊，直接看最重要的一句\n\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n\t\t\n可以看到，只有当shouldRunGC为true时，才会真的去gc，而shouldRunGC的值其实不就是justRanFinalization的值吗，那好，我们全局搜索一下，发现justRanFinalization出现的地方取值可数,只有两个地方:\n\n1、定义的地方\n\n    /**\n     * If we just ran finalization, we might want to do a GC to free the finalized objects.\n     * This lets us do gc/runFinlization/gc sequences but prevents back to back System.gc().\n     */\n    private static boolean justRanFinalization;\n2、赋值的地方\n\n    /**\n     * Provides a hint to the VM that it would be useful to attempt\n     * to perform any outstanding object finalization.\n     */\n    public static void runFinalization() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = runGC;\n            runGC = false;\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n        Runtime.getRuntime().runFinalization();\n        synchronized(lock) {\n            justRanFinalization = true;\n        }\n    }\n\t\n哇咔咔，so easy，这时一个函数出现在我们眼前runFinalization(),这个函数是干嘛的？和System.gc()有什么关系，直接看函数的注释，其实就是执行对象的finalize()方法，但最关键的是，只有在这个地方是justRanFinalization的值才会赋为true，仔细观察，还有一个变量runGC，在System.gc()里会赋值为true，而在System.runFinalization()里只有runGC为\ntrue时，才会真的去触发gc\n\n##总结\n所以说只是单纯的调用System.gc()，在Android5.0以上什么也不会发生，要么是\n1. System.gc()和System.runFinalization()同时调用\n2. 直接调用Runtime.getRuntime().gc()","source":"_posts/systemgc.md","raw":"---\ntitle:  需不需要手动调用System.gc()\ncategories: Android\ntags: Android\n---\n## 导语\n曾几何时，我们一直纠结于到底要不要手动调用System.gc()，有的人说这样调用太丑陋，完全没必要，JVM会帮我们处理好的，有的人说可以调用，这样可以及时释放内存，现在可以明确的告诉你，在Android5.0及以上手动调用System.gc()完全没必要，因为你调了也完全触发不了gc，为什么会这样说呢？\n\n`Talk is cheap,show you the code`\n\n我们直接看代码!\n\n\n## 源码\n\n### Android5.0之前的代码\n\n如下:\n\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\t\n这个看上去完全没问题\n\n### Android 5.0及以后的代码\n\n先看System.gc()到底做了什么，如下:\n\n\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n\n\n简单易懂啊，前面就是一些赋值啊判断啊，直接看最重要的一句\n\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n\t\t\n可以看到，只有当shouldRunGC为true时，才会真的去gc，而shouldRunGC的值其实不就是justRanFinalization的值吗，那好，我们全局搜索一下，发现justRanFinalization出现的地方取值可数,只有两个地方:\n\n1、定义的地方\n\n    /**\n     * If we just ran finalization, we might want to do a GC to free the finalized objects.\n     * This lets us do gc/runFinlization/gc sequences but prevents back to back System.gc().\n     */\n    private static boolean justRanFinalization;\n2、赋值的地方\n\n    /**\n     * Provides a hint to the VM that it would be useful to attempt\n     * to perform any outstanding object finalization.\n     */\n    public static void runFinalization() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = runGC;\n            runGC = false;\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n        Runtime.getRuntime().runFinalization();\n        synchronized(lock) {\n            justRanFinalization = true;\n        }\n    }\n\t\n哇咔咔，so easy，这时一个函数出现在我们眼前runFinalization(),这个函数是干嘛的？和System.gc()有什么关系，直接看函数的注释，其实就是执行对象的finalize()方法，但最关键的是，只有在这个地方是justRanFinalization的值才会赋为true，仔细观察，还有一个变量runGC，在System.gc()里会赋值为true，而在System.runFinalization()里只有runGC为\ntrue时，才会真的去触发gc\n\n##总结\n所以说只是单纯的调用System.gc()，在Android5.0以上什么也不会发生，要么是\n1. System.gc()和System.runFinalization()同时调用\n2. 直接调用Runtime.getRuntime().gc()","slug":"systemgc","published":1,"date":"2017-03-30T13:06:11.925Z","updated":"2017-03-30T13:06:11.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0owh000m4u2d3h3661nb","content":"<h2 id=\"导语\"><a href=\"#导语\" class=\"headerlink\" title=\"导语\"></a>导语</h2><p>曾几何时，我们一直纠结于到底要不要手动调用System.gc()，有的人说这样调用太丑陋，完全没必要，JVM会帮我们处理好的，有的人说可以调用，这样可以及时释放内存，现在可以明确的告诉你，在Android5.0及以上手动调用System.gc()完全没必要，因为你调了也完全触发不了gc，为什么会这样说呢？</p>\n<p><code>Talk is cheap,show you the code</code></p>\n<p>我们直接看代码!</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><h3 id=\"Android5-0之前的代码\"><a href=\"#Android5-0之前的代码\" class=\"headerlink\" title=\"Android5.0之前的代码\"></a>Android5.0之前的代码</h3><p>如下:</p>\n<pre><code>/**\n * Indicates to the VM that it would be a good time to run the\n * garbage collector. Note that this is a hint only. There is no guarantee\n * that the garbage collector will actually be run.\n */\npublic static void gc() {\n    Runtime.getRuntime().gc();\n}\n</code></pre><p>这个看上去完全没问题</p>\n<h3 id=\"Android-5-0及以后的代码\"><a href=\"#Android-5-0及以后的代码\" class=\"headerlink\" title=\"Android 5.0及以后的代码\"></a>Android 5.0及以后的代码</h3><p>先看System.gc()到底做了什么，如下:</p>\n<pre><code>/**\n * Indicates to the VM that it would be a good time to run the\n * garbage collector. Note that this is a hint only. There is no guarantee\n * that the garbage collector will actually be run.\n */\npublic static void gc() {\n    boolean shouldRunGC;\n    synchronized(lock) {\n        shouldRunGC = justRanFinalization;\n        if (shouldRunGC) {\n            justRanFinalization = false;\n        } else {\n            runGC = true;\n        }\n    }\n    if (shouldRunGC) {\n        Runtime.getRuntime().gc();\n    }\n}\n</code></pre><p>简单易懂啊，前面就是一些赋值啊判断啊，直接看最重要的一句</p>\n<pre><code>if (shouldRunGC) {\n    Runtime.getRuntime().gc();\n}\n</code></pre><p>可以看到，只有当shouldRunGC为true时，才会真的去gc，而shouldRunGC的值其实不就是justRanFinalization的值吗，那好，我们全局搜索一下，发现justRanFinalization出现的地方取值可数,只有两个地方:</p>\n<p>1、定义的地方</p>\n<pre><code>/**\n * If we just ran finalization, we might want to do a GC to free the finalized objects.\n * This lets us do gc/runFinlization/gc sequences but prevents back to back System.gc().\n */\nprivate static boolean justRanFinalization;\n</code></pre><p>2、赋值的地方</p>\n<pre><code>/**\n * Provides a hint to the VM that it would be useful to attempt\n * to perform any outstanding object finalization.\n */\npublic static void runFinalization() {\n    boolean shouldRunGC;\n    synchronized(lock) {\n        shouldRunGC = runGC;\n        runGC = false;\n    }\n    if (shouldRunGC) {\n        Runtime.getRuntime().gc();\n    }\n    Runtime.getRuntime().runFinalization();\n    synchronized(lock) {\n        justRanFinalization = true;\n    }\n}\n</code></pre><p>哇咔咔，so easy，这时一个函数出现在我们眼前runFinalization(),这个函数是干嘛的？和System.gc()有什么关系，直接看函数的注释，其实就是执行对象的finalize()方法，但最关键的是，只有在这个地方是justRanFinalization的值才会赋为true，仔细观察，还有一个变量runGC，在System.gc()里会赋值为true，而在System.runFinalization()里只有runGC为<br>true时，才会真的去触发gc</p>\n<p>##总结<br>所以说只是单纯的调用System.gc()，在Android5.0以上什么也不会发生，要么是</p>\n<ol>\n<li>System.gc()和System.runFinalization()同时调用</li>\n<li>直接调用Runtime.getRuntime().gc()</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"导语\"><a href=\"#导语\" class=\"headerlink\" title=\"导语\"></a>导语</h2><p>曾几何时，我们一直纠结于到底要不要手动调用System.gc()，有的人说这样调用太丑陋，完全没必要，JVM会帮我们处理好的，有的人说可以调用，这样可以及时释放内存，现在可以明确的告诉你，在Android5.0及以上手动调用System.gc()完全没必要，因为你调了也完全触发不了gc，为什么会这样说呢？</p>\n<p><code>Talk is cheap,show you the code</code></p>\n<p>我们直接看代码!</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><h3 id=\"Android5-0之前的代码\"><a href=\"#Android5-0之前的代码\" class=\"headerlink\" title=\"Android5.0之前的代码\"></a>Android5.0之前的代码</h3><p>如下:</p>\n<pre><code>/**\n * Indicates to the VM that it would be a good time to run the\n * garbage collector. Note that this is a hint only. There is no guarantee\n * that the garbage collector will actually be run.\n */\npublic static void gc() {\n    Runtime.getRuntime().gc();\n}\n</code></pre><p>这个看上去完全没问题</p>\n<h3 id=\"Android-5-0及以后的代码\"><a href=\"#Android-5-0及以后的代码\" class=\"headerlink\" title=\"Android 5.0及以后的代码\"></a>Android 5.0及以后的代码</h3><p>先看System.gc()到底做了什么，如下:</p>\n<pre><code>/**\n * Indicates to the VM that it would be a good time to run the\n * garbage collector. Note that this is a hint only. There is no guarantee\n * that the garbage collector will actually be run.\n */\npublic static void gc() {\n    boolean shouldRunGC;\n    synchronized(lock) {\n        shouldRunGC = justRanFinalization;\n        if (shouldRunGC) {\n            justRanFinalization = false;\n        } else {\n            runGC = true;\n        }\n    }\n    if (shouldRunGC) {\n        Runtime.getRuntime().gc();\n    }\n}\n</code></pre><p>简单易懂啊，前面就是一些赋值啊判断啊，直接看最重要的一句</p>\n<pre><code>if (shouldRunGC) {\n    Runtime.getRuntime().gc();\n}\n</code></pre><p>可以看到，只有当shouldRunGC为true时，才会真的去gc，而shouldRunGC的值其实不就是justRanFinalization的值吗，那好，我们全局搜索一下，发现justRanFinalization出现的地方取值可数,只有两个地方:</p>\n<p>1、定义的地方</p>\n<pre><code>/**\n * If we just ran finalization, we might want to do a GC to free the finalized objects.\n * This lets us do gc/runFinlization/gc sequences but prevents back to back System.gc().\n */\nprivate static boolean justRanFinalization;\n</code></pre><p>2、赋值的地方</p>\n<pre><code>/**\n * Provides a hint to the VM that it would be useful to attempt\n * to perform any outstanding object finalization.\n */\npublic static void runFinalization() {\n    boolean shouldRunGC;\n    synchronized(lock) {\n        shouldRunGC = runGC;\n        runGC = false;\n    }\n    if (shouldRunGC) {\n        Runtime.getRuntime().gc();\n    }\n    Runtime.getRuntime().runFinalization();\n    synchronized(lock) {\n        justRanFinalization = true;\n    }\n}\n</code></pre><p>哇咔咔，so easy，这时一个函数出现在我们眼前runFinalization(),这个函数是干嘛的？和System.gc()有什么关系，直接看函数的注释，其实就是执行对象的finalize()方法，但最关键的是，只有在这个地方是justRanFinalization的值才会赋为true，仔细观察，还有一个变量runGC，在System.gc()里会赋值为true，而在System.runFinalization()里只有runGC为<br>true时，才会真的去触发gc</p>\n<p>##总结<br>所以说只是单纯的调用System.gc()，在Android5.0以上什么也不会发生，要么是</p>\n<ol>\n<li>System.gc()和System.runFinalization()同时调用</li>\n<li>直接调用Runtime.getRuntime().gc()</li>\n</ol>\n"},{"title":"记一次需求的开发--在ViewPager中嵌套WebView","_content":"\n###  前言\n ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。\n \n### Android事件传递机制\n其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。\n\n我们从事件开始传递的最初入口开始讲起\n### Activity\n事件是从Activity开始传递，具体代码如下：\n`Activity.java`\n```\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n    \t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n在看Window里的superDispatchTouchEvent是怎么实现的\n这里的getWindow返回的winow是PhoneWindow的实例\n`PhoneWindow.java`\n```\n    @Override\n    public boolean superDispatchKeyEvent(KeyEvent event) {\n    \t//这里调用的是mDecor的superDispatchKeyEvent\n        return mDecor.superDispatchKeyEvent(event);\n    }\n```\n\nmDecor是DecorView的实例\n`DecorView.java`\n```\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n       //这里是调用的父类的dispatchKeyShortcutEvent方法\n        return super.dispatchTouchEvent(event);\n    }\n```\nDecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。\nInfiniteData\n第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。\n\n## ViewGroup\n这里就进入到递归的主要逻辑里面，只要把这里搞懂，就搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析\n`dispatchTouchEvent`\n\n```\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n        }\n\n        // If the event targets the accessibility focused view and this is it, start\n        // normal event dispatch. Maybe a descendant is what will handle the click.\n        if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        boolean handled = false;\n        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码\n        if (onFilterTouchEventForSecurity(ev)) {\n        //获取当前事件的action\n            final int action = ev.getAction();\n            //获取当前事件是哪个action\n            final int actionMasked = action & MotionEvent.ACTION_MASK;\n\n            // Handle an initial down.\n            //如果事件为down事件\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递\n            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下\n                    //首先，(mGroupFlags & FLAG_DISALLOW_INTERCEPT) ，因为是&操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            // If intercepted, start normal event dispatch. Also if there is already\n            // a view that is handling the gesture, do normal event dispatch.\n            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发\n            if (intercepted || mFirstTouchTarget != null) {\n                ev.setTargetAccessibilityFocus(false);\n            }\n\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n\n            // Update list of touch targets for pointer down, if needed.\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n            //这里如果canceld和intercept都为false，才会分发事件\n            if (!canceled && !intercepted) {\n\n                // If the event is targeting accessiiblity focus we give it to the\n                // view that has accessibility focus and if it does not handle it\n                // we clear the flag and dispatch the event to all children as usual.\n                // We are looking up the accessibility focused host to avoid keeping\n                // state since these events are very rare.\n                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                        ? findChildWithAccessibilityFocus() : null;\n\n\t\t//这里actionMasked如果符合这些条件\n                if (actionMasked == MotionEvent.ACTION_DOWN\n                        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                    final int actionIndex = ev.getActionIndex(); // always 0 for down\n                    final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n                            : TouchTarget.ALL_POINTER_IDS;\n\n                    // Clean up earlier touch targets for this pointer id in case they\n                    // have become out of sync.\n                    removePointersFromTouchTargets(idBitsToAssign);\n\n\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量\n                    final int childrenCount = mChildrenCount;\n                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了\n                    if (newTouchTarget == null && childrenCount != 0) {\n                        final float x = ev.getX(actionIndex);\n                        final float y = ev.getY(actionIndex);\n                        // Find a child that can receive the event.\n                        // Scan children from front to back.\n                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序\n                        final ArrayList<View> preorderedList = buildOrderedChildList();\n                        final boolean customOrder = preorderedList == null\n                                && isChildrenDrawingOrderEnabled();\n                                //mChildren为全局变量，储存viewgroup的子view\n                        final View[] children = mChildren;\n                        //遍历子view\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = customOrder\n                                    ? getChildDrawingOrder(childrenCount, i) : i;\n                            final View child = (preorderedList == null)\n                                    ? children[childIndex] : preorderedList.get(childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            newTouchTarget = getTouchTarget(child);\n                            if (newTouchTarget != null) {\n                                // Child is already receiving touch within its bounds.\n                                // Give it the new pointer in addition to the ones it is handling.\n                                newTouchTarget.pointerIdBits |= idBitsToAssign;\n                                break;\n                            }\n\n                            resetCancelNextUpFlag(child);\n                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n\n                    if (newTouchTarget == null && mFirstTouchTarget != null) {\n                        // Did not find a child to receive the event.\n                        // Assign the pointer to the least recently added target.\n                        newTouchTarget = mFirstTouchTarget;\n                        while (newTouchTarget.next != null) {\n                            newTouchTarget = newTouchTarget.next;\n                        }\n                        newTouchTarget.pointerIdBits |= idBitsToAssign;\n                    }\n                }\n            }\n\n            // Dispatch to touch targets.\n            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                 //mFirstTouchTarget为null，代表没有可接受事件的子view\n                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n\n            // Update list of touch targets for pointer up or cancel, if needed.\n            if (canceled\n                    || actionMasked == MotionEvent.ACTION_UP\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                resetTouchState();\n            } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n                removePointersFromTouchTargets(idBitsToRemove);\n            }\n        }\n\n        if (!handled && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n        }\n        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，\n        return handled;\n    }\n```\n\n\n`onFilterTouchEventForSecurity`\n```\n根据这个方法的注释，很容易理解这个方法的含义\n/**\n     * Filter the touch event to apply security policies.\n     *\n     * @param event The motion event to be filtered.\n     * @return True if the event should be dispatched, false if the event should be dropped.\n     *\n     * @see #getFilterTouchesWhenObscured\n     */\n    public boolean onFilterTouchEventForSecurity(MotionEvent event) {\n        //noinspection RedundantIfStatement\n        if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0\n                && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {\n            // Window is obscured, drop this touch.\n            return false;\n        }\n        return true;\n    }\n```\n`requestDisallowInterceptTouchEvent`\n```\n/**\n     * {@inheritDoc}\n     */\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\n`dispatchTransformedTouchEvent`\n```\n/**\n     * Transforms a motion event into the coordinate space of a particular child view,\n     * filters out irrelevant pointer ids, and overrides its action if necessary.\n     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.\n     */\n    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n\n        // Canceling motions is a special case.  We don't need to perform any transformations\n        // or filtering.  The important part is the action, not the contents.\n        //看注释，就是这是处理特殊case的代码\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        // Calculate the number of pointers to deliver.\n        final int oldPointerIdBits = event.getPointerIdBits();\n        final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;\n\n        // If for some reason we ended up in an inconsistent state where it looks like we\n        // might produce a motion event with no pointers in it, then drop the event.\n        if (newPointerIdBits == 0) {\n            return false;\n        }\n\n        // If the number of pointers is the same and we don't need to perform any fancy\n        // irreversible transformations, then we can reuse the motion event for this\n        // dispatch as long as we are careful to revert any changes we make.\n        // Otherwise we need to make a copy.\n        final MotionEvent transformedEvent;\n        //这个才是重点\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\t\n\t//这里和上面同理\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n            final float offsetX = mScrollX - child.mLeft;\n            final float offsetY = mScrollY - child.mTop;\n            transformedEvent.offsetLocation(offsetX, offsetY);\n            if (! child.hasIdentityMatrix()) {\n                transformedEvent.transform(child.getInverseMatrix());\n            }\n\n            handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值\n        return handled;\n    }\n```\n\n* 总结\n我们会看到这里有三百多行代码，逻辑非常复杂，但是我们剔除一些不必要的干扰项，其实逻辑还是很清晰的\n\n* 1、第一步，首先，对down事件进行处理，清除上次缓存的状态，在down事件里判断viewgroup是否要拦截事件，首先判断标志位FLAG_DISALLOW_INTERCEPT，``有这个标志位表示不允许拦截``，则直接进行第二步事件的分发；``没有标志未表示允许拦截``，则先调用当前viewgroup的onInterceptTouchEvent，根据onInterceptTouchEvent的值，``如果为true``，表示当前viewgroup要消费这个事件，则执行第三步，即执行该viewgroup的onTouchEvent事件;``如果为false``，则表示当前viewgroup不消费此事件，则执行第二步，对该事件进行分发。\n\n* 2、第二步，要对事件进行分发，如果viewgroup有子view，则按照z-order顺序分发事件，首先判断事件的坐标在不在这个view里面，若是才执行子view的dispatchTouchEvent的方法，``若这个方法返回值为true``，就是有子view消费了此事件，则继续遍历（这里虽然用链表来存储接受事件的view，但是这个view每次应该只有一个，因为同一个事件只能一个view来消费，这里还需探讨？），返回true;``若这个方法返回值为false``，则一直遍历完所有的子view，最后返回false。\n\n\n### View\nview这里的代码就少很多\n`dispatchTouchEvent`\n\n```\n/**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n//这里和viewgroup的一样\n        if (onFilterTouchEventForSecurity(event)) {\n            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\n                result = true;\n            }\n            //noinspection SimplifiableIfStatement\n            //如果有设置onTouchListener，则执行，且返回结果标记为true，代表事件已消费\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n//没有执行上面的onTouchListener，才会执行onTouchEvent\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n```\n\n`onTouchEvent`\n\n```\n /**\n     * Implement this method to handle touch screen motion events.\n     * <p>\n     * If this method is used to detect click actions, it is recommended that\n     * the actions be performed by implementing and calling\n     * {@link #performClick()}. This will ensure consistent system behavior,\n     * including:\n     * <ul>\n     * <li>obeying click sound preferences\n     * <li>dispatching OnClickListener calls\n     * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when\n     * accessibility features are enabled\n     * </ul>\n     *\n     * @param event The motion event.\n     * @return True if the event was handled, false otherwise.\n     */\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n\t//这里要注意只要这个view设置了 CLICKABLE  LONG_CLICKABLE CONTEXT_CLICKABLE这三个属相，那么返回的结果必然为true，而我们一般用到的view绝大部分默认都是设置了的（因为大部分view默认都是可以接受事件的除了View）\n        if (((viewFlags & CLICKABLE) == CLICKABLE ||\n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\n                (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                       }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_DOWN:\n                    mHasPerformedLongPress = false;\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n\n                case MotionEvent.ACTION_CANCEL:\n                    setPressed(false);\n                    removeTapCallback();\n                    removeLongPressCallback();\n                    mInContextButtonPress = false;\n                    mHasPerformedLongPress = false;\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_MOVE:\n                    drawableHotspotChanged(x, y);\n\n                    // Be lenient about moving outside of buttons\n                    if (!pointInView(x, y, mTouchSlop)) {\n                        // Outside button\n                        removeTapCallback();\n                        if ((mPrivateFlags & PFLAG_PRESSED) != 0) {\n                            // Remove any future long press/tap checks\n                            removeLongPressCallback();\n\n                            setPressed(false);\n                        }\n                    }\n                    break;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n```","source":"_posts/viewpager-webview.md","raw":"---\ntitle: 记一次需求的开发--在ViewPager中嵌套WebView\ncategories: Android\ntags: Android\n---\n\n###  前言\n ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。\n \n### Android事件传递机制\n其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。\n\n我们从事件开始传递的最初入口开始讲起\n### Activity\n事件是从Activity开始传递，具体代码如下：\n`Activity.java`\n```\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n    \t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n在看Window里的superDispatchTouchEvent是怎么实现的\n这里的getWindow返回的winow是PhoneWindow的实例\n`PhoneWindow.java`\n```\n    @Override\n    public boolean superDispatchKeyEvent(KeyEvent event) {\n    \t//这里调用的是mDecor的superDispatchKeyEvent\n        return mDecor.superDispatchKeyEvent(event);\n    }\n```\n\nmDecor是DecorView的实例\n`DecorView.java`\n```\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n       //这里是调用的父类的dispatchKeyShortcutEvent方法\n        return super.dispatchTouchEvent(event);\n    }\n```\nDecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。\nInfiniteData\n第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。\n\n## ViewGroup\n这里就进入到递归的主要逻辑里面，只要把这里搞懂，就搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析\n`dispatchTouchEvent`\n\n```\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n        }\n\n        // If the event targets the accessibility focused view and this is it, start\n        // normal event dispatch. Maybe a descendant is what will handle the click.\n        if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        boolean handled = false;\n        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码\n        if (onFilterTouchEventForSecurity(ev)) {\n        //获取当前事件的action\n            final int action = ev.getAction();\n            //获取当前事件是哪个action\n            final int actionMasked = action & MotionEvent.ACTION_MASK;\n\n            // Handle an initial down.\n            //如果事件为down事件\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递\n            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下\n                    //首先，(mGroupFlags & FLAG_DISALLOW_INTERCEPT) ，因为是&操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            // If intercepted, start normal event dispatch. Also if there is already\n            // a view that is handling the gesture, do normal event dispatch.\n            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发\n            if (intercepted || mFirstTouchTarget != null) {\n                ev.setTargetAccessibilityFocus(false);\n            }\n\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n\n            // Update list of touch targets for pointer down, if needed.\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n            //这里如果canceld和intercept都为false，才会分发事件\n            if (!canceled && !intercepted) {\n\n                // If the event is targeting accessiiblity focus we give it to the\n                // view that has accessibility focus and if it does not handle it\n                // we clear the flag and dispatch the event to all children as usual.\n                // We are looking up the accessibility focused host to avoid keeping\n                // state since these events are very rare.\n                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                        ? findChildWithAccessibilityFocus() : null;\n\n\t\t//这里actionMasked如果符合这些条件\n                if (actionMasked == MotionEvent.ACTION_DOWN\n                        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                    final int actionIndex = ev.getActionIndex(); // always 0 for down\n                    final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n                            : TouchTarget.ALL_POINTER_IDS;\n\n                    // Clean up earlier touch targets for this pointer id in case they\n                    // have become out of sync.\n                    removePointersFromTouchTargets(idBitsToAssign);\n\n\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量\n                    final int childrenCount = mChildrenCount;\n                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了\n                    if (newTouchTarget == null && childrenCount != 0) {\n                        final float x = ev.getX(actionIndex);\n                        final float y = ev.getY(actionIndex);\n                        // Find a child that can receive the event.\n                        // Scan children from front to back.\n                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序\n                        final ArrayList<View> preorderedList = buildOrderedChildList();\n                        final boolean customOrder = preorderedList == null\n                                && isChildrenDrawingOrderEnabled();\n                                //mChildren为全局变量，储存viewgroup的子view\n                        final View[] children = mChildren;\n                        //遍历子view\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = customOrder\n                                    ? getChildDrawingOrder(childrenCount, i) : i;\n                            final View child = (preorderedList == null)\n                                    ? children[childIndex] : preorderedList.get(childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            newTouchTarget = getTouchTarget(child);\n                            if (newTouchTarget != null) {\n                                // Child is already receiving touch within its bounds.\n                                // Give it the new pointer in addition to the ones it is handling.\n                                newTouchTarget.pointerIdBits |= idBitsToAssign;\n                                break;\n                            }\n\n                            resetCancelNextUpFlag(child);\n                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n\n                    if (newTouchTarget == null && mFirstTouchTarget != null) {\n                        // Did not find a child to receive the event.\n                        // Assign the pointer to the least recently added target.\n                        newTouchTarget = mFirstTouchTarget;\n                        while (newTouchTarget.next != null) {\n                            newTouchTarget = newTouchTarget.next;\n                        }\n                        newTouchTarget.pointerIdBits |= idBitsToAssign;\n                    }\n                }\n            }\n\n            // Dispatch to touch targets.\n            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                 //mFirstTouchTarget为null，代表没有可接受事件的子view\n                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n\n            // Update list of touch targets for pointer up or cancel, if needed.\n            if (canceled\n                    || actionMasked == MotionEvent.ACTION_UP\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                resetTouchState();\n            } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n                removePointersFromTouchTargets(idBitsToRemove);\n            }\n        }\n\n        if (!handled && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n        }\n        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，\n        return handled;\n    }\n```\n\n\n`onFilterTouchEventForSecurity`\n```\n根据这个方法的注释，很容易理解这个方法的含义\n/**\n     * Filter the touch event to apply security policies.\n     *\n     * @param event The motion event to be filtered.\n     * @return True if the event should be dispatched, false if the event should be dropped.\n     *\n     * @see #getFilterTouchesWhenObscured\n     */\n    public boolean onFilterTouchEventForSecurity(MotionEvent event) {\n        //noinspection RedundantIfStatement\n        if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0\n                && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {\n            // Window is obscured, drop this touch.\n            return false;\n        }\n        return true;\n    }\n```\n`requestDisallowInterceptTouchEvent`\n```\n/**\n     * {@inheritDoc}\n     */\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\n`dispatchTransformedTouchEvent`\n```\n/**\n     * Transforms a motion event into the coordinate space of a particular child view,\n     * filters out irrelevant pointer ids, and overrides its action if necessary.\n     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.\n     */\n    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n\n        // Canceling motions is a special case.  We don't need to perform any transformations\n        // or filtering.  The important part is the action, not the contents.\n        //看注释，就是这是处理特殊case的代码\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        // Calculate the number of pointers to deliver.\n        final int oldPointerIdBits = event.getPointerIdBits();\n        final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;\n\n        // If for some reason we ended up in an inconsistent state where it looks like we\n        // might produce a motion event with no pointers in it, then drop the event.\n        if (newPointerIdBits == 0) {\n            return false;\n        }\n\n        // If the number of pointers is the same and we don't need to perform any fancy\n        // irreversible transformations, then we can reuse the motion event for this\n        // dispatch as long as we are careful to revert any changes we make.\n        // Otherwise we need to make a copy.\n        final MotionEvent transformedEvent;\n        //这个才是重点\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\t\n\t//这里和上面同理\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n            final float offsetX = mScrollX - child.mLeft;\n            final float offsetY = mScrollY - child.mTop;\n            transformedEvent.offsetLocation(offsetX, offsetY);\n            if (! child.hasIdentityMatrix()) {\n                transformedEvent.transform(child.getInverseMatrix());\n            }\n\n            handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值\n        return handled;\n    }\n```\n\n* 总结\n我们会看到这里有三百多行代码，逻辑非常复杂，但是我们剔除一些不必要的干扰项，其实逻辑还是很清晰的\n\n* 1、第一步，首先，对down事件进行处理，清除上次缓存的状态，在down事件里判断viewgroup是否要拦截事件，首先判断标志位FLAG_DISALLOW_INTERCEPT，``有这个标志位表示不允许拦截``，则直接进行第二步事件的分发；``没有标志未表示允许拦截``，则先调用当前viewgroup的onInterceptTouchEvent，根据onInterceptTouchEvent的值，``如果为true``，表示当前viewgroup要消费这个事件，则执行第三步，即执行该viewgroup的onTouchEvent事件;``如果为false``，则表示当前viewgroup不消费此事件，则执行第二步，对该事件进行分发。\n\n* 2、第二步，要对事件进行分发，如果viewgroup有子view，则按照z-order顺序分发事件，首先判断事件的坐标在不在这个view里面，若是才执行子view的dispatchTouchEvent的方法，``若这个方法返回值为true``，就是有子view消费了此事件，则继续遍历（这里虽然用链表来存储接受事件的view，但是这个view每次应该只有一个，因为同一个事件只能一个view来消费，这里还需探讨？），返回true;``若这个方法返回值为false``，则一直遍历完所有的子view，最后返回false。\n\n\n### View\nview这里的代码就少很多\n`dispatchTouchEvent`\n\n```\n/**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n//这里和viewgroup的一样\n        if (onFilterTouchEventForSecurity(event)) {\n            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\n                result = true;\n            }\n            //noinspection SimplifiableIfStatement\n            //如果有设置onTouchListener，则执行，且返回结果标记为true，代表事件已消费\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n\n//没有执行上面的onTouchListener，才会执行onTouchEvent\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n```\n\n`onTouchEvent`\n\n```\n /**\n     * Implement this method to handle touch screen motion events.\n     * <p>\n     * If this method is used to detect click actions, it is recommended that\n     * the actions be performed by implementing and calling\n     * {@link #performClick()}. This will ensure consistent system behavior,\n     * including:\n     * <ul>\n     * <li>obeying click sound preferences\n     * <li>dispatching OnClickListener calls\n     * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when\n     * accessibility features are enabled\n     * </ul>\n     *\n     * @param event The motion event.\n     * @return True if the event was handled, false otherwise.\n     */\n    public boolean onTouchEvent(MotionEvent event) {\n        final float x = event.getX();\n        final float y = event.getY();\n        final int viewFlags = mViewFlags;\n        final int action = event.getAction();\n\n        if ((viewFlags & ENABLED_MASK) == DISABLED) {\n            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\n                setPressed(false);\n            }\n            // A disabled view that is clickable still consumes the touch\n            // events, it just doesn't respond to them.\n            return (((viewFlags & CLICKABLE) == CLICKABLE\n                    || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\n                    || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\n        }\n        if (mTouchDelegate != null) {\n            if (mTouchDelegate.onTouchEvent(event)) {\n                return true;\n            }\n        }\n\n\t//这里要注意只要这个view设置了 CLICKABLE  LONG_CLICKABLE CONTEXT_CLICKABLE这三个属相，那么返回的结果必然为true，而我们一般用到的view绝大部分默认都是设置了的（因为大部分view默认都是可以接受事件的除了View）\n        if (((viewFlags & CLICKABLE) == CLICKABLE ||\n                (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\n                (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\n            switch (action) {\n                case MotionEvent.ACTION_UP:\n                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\n                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\n                        // take focus if we don't have it already and we should in\n                        // touch mode.\n                        boolean focusTaken = false;\n                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\n                            focusTaken = requestFocus();\n                        }\n\n                        if (prepressed) {\n                            // The button is being released before we actually\n                            // showed it as pressed.  Make it show the pressed\n                            // state now (before scheduling the click) to ensure\n                            // the user sees it.\n                            setPressed(true, x, y);\n                       }\n\n                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\n                            // This is a tap, so remove the longpress check\n                            removeLongPressCallback();\n\n                            // Only perform take click actions if we were in the pressed state\n                            if (!focusTaken) {\n                                // Use a Runnable and post this rather than calling\n                                // performClick directly. This lets other visual state\n                                // of the view update before click actions start.\n                                if (mPerformClick == null) {\n                                    mPerformClick = new PerformClick();\n                                }\n                                if (!post(mPerformClick)) {\n                                    performClick();\n                                }\n                            }\n                        }\n\n                        if (mUnsetPressedState == null) {\n                            mUnsetPressedState = new UnsetPressedState();\n                        }\n\n                        if (prepressed) {\n                            postDelayed(mUnsetPressedState,\n                                    ViewConfiguration.getPressedStateDuration());\n                        } else if (!post(mUnsetPressedState)) {\n                            // If the post failed, unpress right now\n                            mUnsetPressedState.run();\n                        }\n\n                        removeTapCallback();\n                    }\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_DOWN:\n                    mHasPerformedLongPress = false;\n\n                    if (performButtonActionOnTouchDown(event)) {\n                        break;\n                    }\n\n                    // Walk up the hierarchy to determine if we're inside a scrolling container.\n                    boolean isInScrollingContainer = isInScrollingContainer();\n\n                    // For views inside a scrolling container, delay the pressed feedback for\n                    // a short period in case this is a scroll.\n                    if (isInScrollingContainer) {\n                        mPrivateFlags |= PFLAG_PREPRESSED;\n                        if (mPendingCheckForTap == null) {\n                            mPendingCheckForTap = new CheckForTap();\n                        }\n                        mPendingCheckForTap.x = event.getX();\n                        mPendingCheckForTap.y = event.getY();\n                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\n                    } else {\n                        // Not inside a scrolling container, so show the feedback right away\n                        setPressed(true, x, y);\n                        checkForLongClick(0, x, y);\n                    }\n                    break;\n\n                case MotionEvent.ACTION_CANCEL:\n                    setPressed(false);\n                    removeTapCallback();\n                    removeLongPressCallback();\n                    mInContextButtonPress = false;\n                    mHasPerformedLongPress = false;\n                    mIgnoreNextUpEvent = false;\n                    break;\n\n                case MotionEvent.ACTION_MOVE:\n                    drawableHotspotChanged(x, y);\n\n                    // Be lenient about moving outside of buttons\n                    if (!pointInView(x, y, mTouchSlop)) {\n                        // Outside button\n                        removeTapCallback();\n                        if ((mPrivateFlags & PFLAG_PRESSED) != 0) {\n                            // Remove any future long press/tap checks\n                            removeLongPressCallback();\n\n                            setPressed(false);\n                        }\n                    }\n                    break;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n```","slug":"viewpager-webview","published":1,"date":"2017-03-12T11:50:01.103Z","updated":"2017-03-12T11:50:01.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0wf0owi000o4u2di3vlqnqy","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p> ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。</p>\n<h3 id=\"Android事件传递机制\"><a href=\"#Android事件传递机制\" class=\"headerlink\" title=\"Android事件传递机制\"></a>Android事件传递机制</h3><p>其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。</p>\n<p>我们从事件开始传递的最初入口开始讲起</p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>事件是从Activity开始传递，具体代码如下：<br><code>Activity.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空</div><div class=\"line\">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件</div><div class=\"line\">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在看Window里的superDispatchTouchEvent是怎么实现的<br>这里的getWindow返回的winow是PhoneWindow的实例<br><code>PhoneWindow.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean superDispatchKeyEvent(KeyEvent event) &#123;</div><div class=\"line\">\t//这里调用的是mDecor的superDispatchKeyEvent</div><div class=\"line\">    return mDecor.superDispatchKeyEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>mDecor是DecorView的实例<br><code>DecorView.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       //这里是调用的父类的dispatchKeyShortcutEvent方法</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>DecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。<br>InfiniteData<br>第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。</p>\n<h2 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h2><p>这里就进入到递归的主要逻辑里面，只要把这里搞懂，就搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的</div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the event targets the accessibility focused view and this is it, start</div><div class=\"line\">        // normal event dispatch. Maybe a descendant is what will handle the click.</div><div class=\"line\">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean handled = false;</div><div class=\"line\">        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码</div><div class=\"line\">        if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class=\"line\">        //获取当前事件的action</div><div class=\"line\">            final int action = ev.getAction();</div><div class=\"line\">            //获取当前事件是哪个action</div><div class=\"line\">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class=\"line\"></div><div class=\"line\">            // Handle an initial down.</div><div class=\"line\">            //如果事件为down事件</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">                // Throw away all previous state when starting a new touch gesture.</div><div class=\"line\">                // The framework may have dropped the up or cancel event for the previous gesture</div><div class=\"line\">                // due to an app switch, ANR, or some other state change.</div><div class=\"line\">                cancelAndClearTouchTargets(ev);</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for interception.</div><div class=\"line\">            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递</div><div class=\"line\">            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去</div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下</div><div class=\"line\">                    //首先，(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) ，因为是&amp;操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If intercepted, start normal event dispatch. Also if there is already</div><div class=\"line\">            // a view that is handling the gesture, do normal event dispatch.</div><div class=\"line\">            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发</div><div class=\"line\">            if (intercepted || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for cancelation.</div><div class=\"line\">            final boolean canceled = resetCancelNextUpFlag(this)</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer down, if needed.</div><div class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class=\"line\">            TouchTarget newTouchTarget = null;</div><div class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</div><div class=\"line\">            //这里如果canceld和intercept都为false，才会分发事件</div><div class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</div><div class=\"line\"></div><div class=\"line\">                // If the event is targeting accessiiblity focus we give it to the</div><div class=\"line\">                // view that has accessibility focus and if it does not handle it</div><div class=\"line\">                // we clear the flag and dispatch the event to all children as usual.</div><div class=\"line\">                // We are looking up the accessibility focused host to avoid keeping</div><div class=\"line\">                // state since these events are very rare.</div><div class=\"line\">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class=\"line\">                        ? findChildWithAccessibilityFocus() : null;</div><div class=\"line\"></div><div class=\"line\">\t\t//这里actionMasked如果符合这些条件</div><div class=\"line\">                if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class=\"line\">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class=\"line\">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class=\"line\">                            : TouchTarget.ALL_POINTER_IDS;</div><div class=\"line\"></div><div class=\"line\">                    // Clean up earlier touch targets for this pointer id in case they</div><div class=\"line\">                    // have become out of sync.</div><div class=\"line\">                    removePointersFromTouchTargets(idBitsToAssign);</div><div class=\"line\"></div><div class=\"line\">\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量</div><div class=\"line\">                    final int childrenCount = mChildrenCount;</div><div class=\"line\">                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了</div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class=\"line\">                        final float x = ev.getX(actionIndex);</div><div class=\"line\">                        final float y = ev.getY(actionIndex);</div><div class=\"line\">                        // Find a child that can receive the event.</div><div class=\"line\">                        // Scan children from front to back.</div><div class=\"line\">                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序</div><div class=\"line\">                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class=\"line\">                        final boolean customOrder = preorderedList == null</div><div class=\"line\">                                &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class=\"line\">                                //mChildren为全局变量，储存viewgroup的子view</div><div class=\"line\">                        final View[] children = mChildren;</div><div class=\"line\">                        //遍历子view</div><div class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">                            final int childIndex = customOrder</div><div class=\"line\">                                    ? getChildDrawingOrder(childrenCount, i) : i;</div><div class=\"line\">                            final View child = (preorderedList == null)</div><div class=\"line\">                                    ? children[childIndex] : preorderedList.get(childIndex);</div><div class=\"line\"></div><div class=\"line\">                            // If there is a view that has accessibility focus we want it</div><div class=\"line\">                            // to get the event first and if not handled we will perform a</div><div class=\"line\">                            // normal dispatch. We may do a double iteration but this is</div><div class=\"line\">                            // safer given the timeframe.</div><div class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</div><div class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</div><div class=\"line\">                                    continue;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                childWithAccessibilityFocus = null;</div><div class=\"line\">                                i = childrenCount - 1;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            if (!canViewReceivePointerEvents(child)</div><div class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class=\"line\">                                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                                continue;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            newTouchTarget = getTouchTarget(child);</div><div class=\"line\">                            if (newTouchTarget != null) &#123;</div><div class=\"line\">                                // Child is already receiving touch within its bounds.</div><div class=\"line\">                                // Give it the new pointer in addition to the ones it is handling.</div><div class=\"line\">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            resetCancelNextUpFlag(child);</div><div class=\"line\">                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发</div><div class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class=\"line\">                                // Child wants to receive touch within its bounds.</div><div class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</div><div class=\"line\">                                if (preorderedList != null) &#123;</div><div class=\"line\">                                    // childIndex points into presorted list, find original index</div><div class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class=\"line\">                                            mLastTouchDownIndex = j;</div><div class=\"line\">                                            break;</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125; else &#123;</div><div class=\"line\">                                    mLastTouchDownIndex = childIndex;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                mLastTouchDownX = ev.getX();</div><div class=\"line\">                                mLastTouchDownY = ev.getY();</div><div class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</div><div class=\"line\">                            // the flag and do a normal dispatch to all children.</div><div class=\"line\">                            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (preorderedList != null) preorderedList.clear();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class=\"line\">                        // Did not find a child to receive the event.</div><div class=\"line\">                        // Assign the pointer to the least recently added target.</div><div class=\"line\">                        newTouchTarget = mFirstTouchTarget;</div><div class=\"line\">                        while (newTouchTarget.next != null) &#123;</div><div class=\"line\">                            newTouchTarget = newTouchTarget.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dispatch to touch targets.</div><div class=\"line\">            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存</div><div class=\"line\">            if (mFirstTouchTarget == null) &#123;</div><div class=\"line\">                // No touch targets so treat this as an ordinary view.</div><div class=\"line\">                 //mFirstTouchTarget为null，代表没有可接受事件的子view</div><div class=\"line\">                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件</div><div class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</div><div class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</div><div class=\"line\">                TouchTarget predecessor = null;</div><div class=\"line\">                TouchTarget target = mFirstTouchTarget;</div><div class=\"line\">                while (target != null) &#123;</div><div class=\"line\">                    final TouchTarget next = target.next;</div><div class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class=\"line\">                        handled = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class=\"line\">                                || intercepted;</div><div class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class=\"line\">                                target.child, target.pointerIdBits)) &#123;</div><div class=\"line\">                            handled = true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (cancelChild) &#123;</div><div class=\"line\">                            if (predecessor == null) &#123;</div><div class=\"line\">                                mFirstTouchTarget = next;</div><div class=\"line\">                            &#125; else &#123;</div><div class=\"line\">                                predecessor.next = next;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            target.recycle();</div><div class=\"line\">                            target = next;</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    predecessor = target;</div><div class=\"line\">                    target = next;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer up or cancel, if needed.</div><div class=\"line\">            if (canceled</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_UP</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class=\"line\">                final int actionIndex = ev.getActionIndex();</div><div class=\"line\">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class=\"line\">                removePointersFromTouchTargets(idBitsToRemove);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onFilterTouchEventForSecurity</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据这个方法的注释，很容易理解这个方法的含义</div><div class=\"line\">/**</div><div class=\"line\">     * Filter the touch event to apply security policies.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be filtered.</div><div class=\"line\">     * @return True if the event should be dispatched, false if the event should be dropped.</div><div class=\"line\">     *</div><div class=\"line\">     * @see #getFilterTouchesWhenObscured</div><div class=\"line\">     */</div><div class=\"line\">    public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</div><div class=\"line\">        //noinspection RedundantIfStatement</div><div class=\"line\">        if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</div><div class=\"line\">                &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</div><div class=\"line\">            // Window is obscured, drop this touch.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>requestDisallowInterceptTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * &#123;@inheritDoc&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</div><div class=\"line\">            // We&apos;re already in this state, assume our ancestors are too</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept) &#123;</div><div class=\"line\">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Pass it up to our parent</div><div class=\"line\">        if (mParent != null) &#123;</div><div class=\"line\">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>dispatchTransformedTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Transforms a motion event into the coordinate space of a particular child view,</div><div class=\"line\">     * filters out irrelevant pointer ids, and overrides its action if necessary.</div><div class=\"line\">     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</div><div class=\"line\">     */</div><div class=\"line\">    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class=\"line\">            View child, int desiredPointerIdBits) &#123;</div><div class=\"line\">        final boolean handled;</div><div class=\"line\"></div><div class=\"line\">        // Canceling motions is a special case.  We don&apos;t need to perform any transformations</div><div class=\"line\">        // or filtering.  The important part is the action, not the contents.</div><div class=\"line\">        //看注释，就是这是处理特殊case的代码</div><div class=\"line\">        final int oldAction = event.getAction();</div><div class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</div><div class=\"line\">            if (child == null) &#123;</div><div class=\"line\">                handled = super.dispatchTouchEvent(event);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handled = child.dispatchTouchEvent(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            event.setAction(oldAction);</div><div class=\"line\">            return handled;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Calculate the number of pointers to deliver.</div><div class=\"line\">        final int oldPointerIdBits = event.getPointerIdBits();</div><div class=\"line\">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class=\"line\"></div><div class=\"line\">        // If for some reason we ended up in an inconsistent state where it looks like we</div><div class=\"line\">        // might produce a motion event with no pointers in it, then drop the event.</div><div class=\"line\">        if (newPointerIdBits == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the number of pointers is the same and we don&apos;t need to perform any fancy</div><div class=\"line\">        // irreversible transformations, then we can reuse the motion event for this</div><div class=\"line\">        // dispatch as long as we are careful to revert any changes we make.</div><div class=\"line\">        // Otherwise we need to make a copy.</div><div class=\"line\">        final MotionEvent transformedEvent;</div><div class=\"line\">        //这个才是重点</div><div class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                if (child == null) &#123;</div><div class=\"line\">                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件</div><div class=\"line\">                    handled = super.dispatchTouchEvent(event);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">                    final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">                    event.offsetLocation(offsetX, offsetY);</div><div class=\"line\">\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view</div><div class=\"line\">                    handled = child.dispatchTouchEvent(event);</div><div class=\"line\"></div><div class=\"line\">                    event.offsetLocation(-offsetX, -offsetY);</div><div class=\"line\">                &#125;</div><div class=\"line\">                return handled;</div><div class=\"line\">            &#125;</div><div class=\"line\">            transformedEvent = MotionEvent.obtain(event);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            transformedEvent = event.split(newPointerIdBits);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//这里和上面同理</div><div class=\"line\">        // Perform any necessary transformations and dispatch.</div><div class=\"line\">        if (child == null) &#123;</div><div class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">            final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">            transformedEvent.offsetLocation(offsetX, offsetY);</div><div class=\"line\">            if (! child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                transformedEvent.transform(child.getInverseMatrix());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handled = child.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Done.</div><div class=\"line\">        transformedEvent.recycle();</div><div class=\"line\">        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>总结<br>我们会看到这里有三百多行代码，逻辑非常复杂，但是我们剔除一些不必要的干扰项，其实逻辑还是很清晰的</p>\n</li>\n<li><p>1、第一步，首先，对down事件进行处理，清除上次缓存的状态，在down事件里判断viewgroup是否要拦截事件，首先判断标志位FLAG_DISALLOW_INTERCEPT，<code>有这个标志位表示不允许拦截</code>，则直接进行第二步事件的分发；<code>没有标志未表示允许拦截</code>，则先调用当前viewgroup的onInterceptTouchEvent，根据onInterceptTouchEvent的值，<code>如果为true</code>，表示当前viewgroup要消费这个事件，则执行第三步，即执行该viewgroup的onTouchEvent事件;<code>如果为false</code>，则表示当前viewgroup不消费此事件，则执行第二步，对该事件进行分发。</p>\n</li>\n<li><p>2、第二步，要对事件进行分发，如果viewgroup有子view，则按照z-order顺序分发事件，首先判断事件的坐标在不在这个view里面，若是才执行子view的dispatchTouchEvent的方法，<code>若这个方法返回值为true</code>，就是有子view消费了此事件，则继续遍历（这里虽然用链表来存储接受事件的view，但是这个view每次应该只有一个，因为同一个事件只能一个view来消费，这里还需探讨？），返回true;<code>若这个方法返回值为false</code>，则一直遍历完所有的子view，最后返回false。</p>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>view这里的代码就少很多<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Pass the touch screen motion event down to the target view, or this</div><div class=\"line\">     * view if it is the target.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be dispatched.</div><div class=\"line\">     * @return True if the event was handled by the view, false otherwise.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        // If the event should be handled by accessibility focus first.</div><div class=\"line\">        if (event.isTargetAccessibilityFocus()) &#123;</div><div class=\"line\">            // We don&apos;t have focus or no virtual descendant has it, do not handle the event.</div><div class=\"line\">            if (!isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // We have focus and got the event, then use normal event dispatch.</div><div class=\"line\">            event.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean result = false;</div><div class=\"line\"></div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(event, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final int actionMasked = event.getActionMasked();</div><div class=\"line\">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            // Defensive cleanup for new gesture</div><div class=\"line\">            stopNestedScroll();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">//这里和viewgroup的一样</div><div class=\"line\">        if (onFilterTouchEventForSecurity(event)) &#123;</div><div class=\"line\">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //noinspection SimplifiableIfStatement</div><div class=\"line\">            //如果有设置onTouchListener，则执行，且返回结果标记为true，代表事件已消费</div><div class=\"line\">            ListenerInfo li = mListenerInfo;</div><div class=\"line\">            if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class=\"line\">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class=\"line\">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">//没有执行上面的onTouchListener，才会执行onTouchEvent</div><div class=\"line\">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Clean up after nested scrolls if this is the end of a gesture;</div><div class=\"line\">        // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest</div><div class=\"line\">        // of the gesture.</div><div class=\"line\">        if (actionMasked == MotionEvent.ACTION_UP ||</div><div class=\"line\">                actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class=\"line\">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class=\"line\">            stopNestedScroll();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">    * Implement this method to handle touch screen motion events.</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * If this method is used to detect click actions, it is recommended that</div><div class=\"line\">    * the actions be performed by implementing and calling</div><div class=\"line\">    * &#123;@link #performClick()&#125;. This will ensure consistent system behavior,</div><div class=\"line\">    * including:</div><div class=\"line\">    * &lt;ul&gt;</div><div class=\"line\">    * &lt;li&gt;obeying click sound preferences</div><div class=\"line\">    * &lt;li&gt;dispatching OnClickListener calls</div><div class=\"line\">    * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when</div><div class=\"line\">    * accessibility features are enabled</div><div class=\"line\">    * &lt;/ul&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * @param event The motion event.</div><div class=\"line\">    * @return True if the event was handled, false otherwise.</div><div class=\"line\">    */</div><div class=\"line\">   public boolean onTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       final float x = event.getX();</div><div class=\"line\">       final float y = event.getY();</div><div class=\"line\">       final int viewFlags = mViewFlags;</div><div class=\"line\">       final int action = event.getAction();</div><div class=\"line\"></div><div class=\"line\">       if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class=\"line\">           if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class=\"line\">               setPressed(false);</div><div class=\"line\">           &#125;</div><div class=\"line\">           // A disabled view that is clickable still consumes the touch</div><div class=\"line\">           // events, it just doesn&apos;t respond to them.</div><div class=\"line\">           return (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class=\"line\">                   || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class=\"line\">                   || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (mTouchDelegate != null) &#123;</div><div class=\"line\">           if (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class=\"line\">               return true;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">//这里要注意只要这个view设置了 CLICKABLE  LONG_CLICKABLE CONTEXT_CLICKABLE这三个属相，那么返回的结果必然为true，而我们一般用到的view绝大部分默认都是设置了的（因为大部分view默认都是可以接受事件的除了View）</div><div class=\"line\">       if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class=\"line\">               (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class=\"line\">               (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class=\"line\">           switch (action) &#123;</div><div class=\"line\">               case MotionEvent.ACTION_UP:</div><div class=\"line\">                   boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</div><div class=\"line\">                   if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</div><div class=\"line\">                       // take focus if we don&apos;t have it already and we should in</div><div class=\"line\">                       // touch mode.</div><div class=\"line\">                       boolean focusTaken = false;</div><div class=\"line\">                       if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class=\"line\">                           focusTaken = requestFocus();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (prepressed) &#123;</div><div class=\"line\">                           // The button is being released before we actually</div><div class=\"line\">                           // showed it as pressed.  Make it show the pressed</div><div class=\"line\">                           // state now (before scheduling the click) to ensure</div><div class=\"line\">                           // the user sees it.</div><div class=\"line\">                           setPressed(true, x, y);</div><div class=\"line\">                      &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                           // This is a tap, so remove the longpress check</div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           // Only perform take click actions if we were in the pressed state</div><div class=\"line\">                           if (!focusTaken) &#123;</div><div class=\"line\">                               // Use a Runnable and post this rather than calling</div><div class=\"line\">                               // performClick directly. This lets other visual state</div><div class=\"line\">                               // of the view update before click actions start.</div><div class=\"line\">                               if (mPerformClick == null) &#123;</div><div class=\"line\">                                   mPerformClick = new PerformClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                               if (!post(mPerformClick)) &#123;</div><div class=\"line\">                                   performClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (mUnsetPressedState == null) &#123;</div><div class=\"line\">                           mUnsetPressedState = new UnsetPressedState();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (prepressed) &#123;</div><div class=\"line\">                           postDelayed(mUnsetPressedState,</div><div class=\"line\">                                   ViewConfiguration.getPressedStateDuration());</div><div class=\"line\">                       &#125; else if (!post(mUnsetPressedState)) &#123;</div><div class=\"line\">                           // If the post failed, unpress right now</div><div class=\"line\">                           mUnsetPressedState.run();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       removeTapCallback();</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   mIgnoreNextUpEvent = false;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                   mHasPerformedLongPress = false;</div><div class=\"line\"></div><div class=\"line\">                   if (performButtonActionOnTouchDown(event)) &#123;</div><div class=\"line\">                       break;</div><div class=\"line\">                   &#125;</div><div class=\"line\"></div><div class=\"line\">                   // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</div><div class=\"line\">                   boolean isInScrollingContainer = isInScrollingContainer();</div><div class=\"line\"></div><div class=\"line\">                   // For views inside a scrolling container, delay the pressed feedback for</div><div class=\"line\">                   // a short period in case this is a scroll.</div><div class=\"line\">                   if (isInScrollingContainer) &#123;</div><div class=\"line\">                       mPrivateFlags |= PFLAG_PREPRESSED;</div><div class=\"line\">                       if (mPendingCheckForTap == null) &#123;</div><div class=\"line\">                           mPendingCheckForTap = new CheckForTap();</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       mPendingCheckForTap.x = event.getX();</div><div class=\"line\">                       mPendingCheckForTap.y = event.getY();</div><div class=\"line\">                       postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       // Not inside a scrolling container, so show the feedback right away</div><div class=\"line\">                       setPressed(true, x, y);</div><div class=\"line\">                       checkForLongClick(0, x, y);</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                   setPressed(false);</div><div class=\"line\">                   removeTapCallback();</div><div class=\"line\">                   removeLongPressCallback();</div><div class=\"line\">                   mInContextButtonPress = false;</div><div class=\"line\">                   mHasPerformedLongPress = false;</div><div class=\"line\">                   mIgnoreNextUpEvent = false;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                   drawableHotspotChanged(x, y);</div><div class=\"line\"></div><div class=\"line\">                   // Be lenient about moving outside of buttons</div><div class=\"line\">                   if (!pointInView(x, y, mTouchSlop)) &#123;</div><div class=\"line\">                       // Outside button</div><div class=\"line\">                       removeTapCallback();</div><div class=\"line\">                       if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class=\"line\">                           // Remove any future long press/tap checks</div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           setPressed(false);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   break;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           return true;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return false;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p> ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。</p>\n<h3 id=\"Android事件传递机制\"><a href=\"#Android事件传递机制\" class=\"headerlink\" title=\"Android事件传递机制\"></a>Android事件传递机制</h3><p>其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。</p>\n<p>我们从事件开始传递的最初入口开始讲起</p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>事件是从Activity开始传递，具体代码如下：<br><code>Activity.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空</div><div class=\"line\">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件</div><div class=\"line\">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在看Window里的superDispatchTouchEvent是怎么实现的<br>这里的getWindow返回的winow是PhoneWindow的实例<br><code>PhoneWindow.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean superDispatchKeyEvent(KeyEvent event) &#123;</div><div class=\"line\">\t//这里调用的是mDecor的superDispatchKeyEvent</div><div class=\"line\">    return mDecor.superDispatchKeyEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>mDecor是DecorView的实例<br><code>DecorView.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       //这里是调用的父类的dispatchKeyShortcutEvent方法</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>DecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。<br>InfiniteData<br>第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。</p>\n<h2 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h2><p>这里就进入到递归的主要逻辑里面，只要把这里搞懂，就搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的</div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the event targets the accessibility focused view and this is it, start</div><div class=\"line\">        // normal event dispatch. Maybe a descendant is what will handle the click.</div><div class=\"line\">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean handled = false;</div><div class=\"line\">        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码</div><div class=\"line\">        if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class=\"line\">        //获取当前事件的action</div><div class=\"line\">            final int action = ev.getAction();</div><div class=\"line\">            //获取当前事件是哪个action</div><div class=\"line\">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class=\"line\"></div><div class=\"line\">            // Handle an initial down.</div><div class=\"line\">            //如果事件为down事件</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">                // Throw away all previous state when starting a new touch gesture.</div><div class=\"line\">                // The framework may have dropped the up or cancel event for the previous gesture</div><div class=\"line\">                // due to an app switch, ANR, or some other state change.</div><div class=\"line\">                cancelAndClearTouchTargets(ev);</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for interception.</div><div class=\"line\">            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递</div><div class=\"line\">            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去</div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下</div><div class=\"line\">                    //首先，(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) ，因为是&amp;操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If intercepted, start normal event dispatch. Also if there is already</div><div class=\"line\">            // a view that is handling the gesture, do normal event dispatch.</div><div class=\"line\">            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发</div><div class=\"line\">            if (intercepted || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for cancelation.</div><div class=\"line\">            final boolean canceled = resetCancelNextUpFlag(this)</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer down, if needed.</div><div class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class=\"line\">            TouchTarget newTouchTarget = null;</div><div class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</div><div class=\"line\">            //这里如果canceld和intercept都为false，才会分发事件</div><div class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</div><div class=\"line\"></div><div class=\"line\">                // If the event is targeting accessiiblity focus we give it to the</div><div class=\"line\">                // view that has accessibility focus and if it does not handle it</div><div class=\"line\">                // we clear the flag and dispatch the event to all children as usual.</div><div class=\"line\">                // We are looking up the accessibility focused host to avoid keeping</div><div class=\"line\">                // state since these events are very rare.</div><div class=\"line\">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class=\"line\">                        ? findChildWithAccessibilityFocus() : null;</div><div class=\"line\"></div><div class=\"line\">\t\t//这里actionMasked如果符合这些条件</div><div class=\"line\">                if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class=\"line\">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class=\"line\">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class=\"line\">                            : TouchTarget.ALL_POINTER_IDS;</div><div class=\"line\"></div><div class=\"line\">                    // Clean up earlier touch targets for this pointer id in case they</div><div class=\"line\">                    // have become out of sync.</div><div class=\"line\">                    removePointersFromTouchTargets(idBitsToAssign);</div><div class=\"line\"></div><div class=\"line\">\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量</div><div class=\"line\">                    final int childrenCount = mChildrenCount;</div><div class=\"line\">                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了</div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class=\"line\">                        final float x = ev.getX(actionIndex);</div><div class=\"line\">                        final float y = ev.getY(actionIndex);</div><div class=\"line\">                        // Find a child that can receive the event.</div><div class=\"line\">                        // Scan children from front to back.</div><div class=\"line\">                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序</div><div class=\"line\">                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class=\"line\">                        final boolean customOrder = preorderedList == null</div><div class=\"line\">                                &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class=\"line\">                                //mChildren为全局变量，储存viewgroup的子view</div><div class=\"line\">                        final View[] children = mChildren;</div><div class=\"line\">                        //遍历子view</div><div class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">                            final int childIndex = customOrder</div><div class=\"line\">                                    ? getChildDrawingOrder(childrenCount, i) : i;</div><div class=\"line\">                            final View child = (preorderedList == null)</div><div class=\"line\">                                    ? children[childIndex] : preorderedList.get(childIndex);</div><div class=\"line\"></div><div class=\"line\">                            // If there is a view that has accessibility focus we want it</div><div class=\"line\">                            // to get the event first and if not handled we will perform a</div><div class=\"line\">                            // normal dispatch. We may do a double iteration but this is</div><div class=\"line\">                            // safer given the timeframe.</div><div class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</div><div class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</div><div class=\"line\">                                    continue;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                childWithAccessibilityFocus = null;</div><div class=\"line\">                                i = childrenCount - 1;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            if (!canViewReceivePointerEvents(child)</div><div class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class=\"line\">                                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                                continue;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            newTouchTarget = getTouchTarget(child);</div><div class=\"line\">                            if (newTouchTarget != null) &#123;</div><div class=\"line\">                                // Child is already receiving touch within its bounds.</div><div class=\"line\">                                // Give it the new pointer in addition to the ones it is handling.</div><div class=\"line\">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            resetCancelNextUpFlag(child);</div><div class=\"line\">                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发</div><div class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class=\"line\">                                // Child wants to receive touch within its bounds.</div><div class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</div><div class=\"line\">                                if (preorderedList != null) &#123;</div><div class=\"line\">                                    // childIndex points into presorted list, find original index</div><div class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class=\"line\">                                            mLastTouchDownIndex = j;</div><div class=\"line\">                                            break;</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125; else &#123;</div><div class=\"line\">                                    mLastTouchDownIndex = childIndex;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                mLastTouchDownX = ev.getX();</div><div class=\"line\">                                mLastTouchDownY = ev.getY();</div><div class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</div><div class=\"line\">                            // the flag and do a normal dispatch to all children.</div><div class=\"line\">                            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (preorderedList != null) preorderedList.clear();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class=\"line\">                        // Did not find a child to receive the event.</div><div class=\"line\">                        // Assign the pointer to the least recently added target.</div><div class=\"line\">                        newTouchTarget = mFirstTouchTarget;</div><div class=\"line\">                        while (newTouchTarget.next != null) &#123;</div><div class=\"line\">                            newTouchTarget = newTouchTarget.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dispatch to touch targets.</div><div class=\"line\">            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存</div><div class=\"line\">            if (mFirstTouchTarget == null) &#123;</div><div class=\"line\">                // No touch targets so treat this as an ordinary view.</div><div class=\"line\">                 //mFirstTouchTarget为null，代表没有可接受事件的子view</div><div class=\"line\">                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件</div><div class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</div><div class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</div><div class=\"line\">                TouchTarget predecessor = null;</div><div class=\"line\">                TouchTarget target = mFirstTouchTarget;</div><div class=\"line\">                while (target != null) &#123;</div><div class=\"line\">                    final TouchTarget next = target.next;</div><div class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class=\"line\">                        handled = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class=\"line\">                                || intercepted;</div><div class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class=\"line\">                                target.child, target.pointerIdBits)) &#123;</div><div class=\"line\">                            handled = true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (cancelChild) &#123;</div><div class=\"line\">                            if (predecessor == null) &#123;</div><div class=\"line\">                                mFirstTouchTarget = next;</div><div class=\"line\">                            &#125; else &#123;</div><div class=\"line\">                                predecessor.next = next;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            target.recycle();</div><div class=\"line\">                            target = next;</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    predecessor = target;</div><div class=\"line\">                    target = next;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer up or cancel, if needed.</div><div class=\"line\">            if (canceled</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_UP</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class=\"line\">                final int actionIndex = ev.getActionIndex();</div><div class=\"line\">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class=\"line\">                removePointersFromTouchTargets(idBitsToRemove);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onFilterTouchEventForSecurity</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据这个方法的注释，很容易理解这个方法的含义</div><div class=\"line\">/**</div><div class=\"line\">     * Filter the touch event to apply security policies.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be filtered.</div><div class=\"line\">     * @return True if the event should be dispatched, false if the event should be dropped.</div><div class=\"line\">     *</div><div class=\"line\">     * @see #getFilterTouchesWhenObscured</div><div class=\"line\">     */</div><div class=\"line\">    public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</div><div class=\"line\">        //noinspection RedundantIfStatement</div><div class=\"line\">        if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</div><div class=\"line\">                &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</div><div class=\"line\">            // Window is obscured, drop this touch.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>requestDisallowInterceptTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * &#123;@inheritDoc&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</div><div class=\"line\">            // We&apos;re already in this state, assume our ancestors are too</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept) &#123;</div><div class=\"line\">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Pass it up to our parent</div><div class=\"line\">        if (mParent != null) &#123;</div><div class=\"line\">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>dispatchTransformedTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Transforms a motion event into the coordinate space of a particular child view,</div><div class=\"line\">     * filters out irrelevant pointer ids, and overrides its action if necessary.</div><div class=\"line\">     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</div><div class=\"line\">     */</div><div class=\"line\">    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class=\"line\">            View child, int desiredPointerIdBits) &#123;</div><div class=\"line\">        final boolean handled;</div><div class=\"line\"></div><div class=\"line\">        // Canceling motions is a special case.  We don&apos;t need to perform any transformations</div><div class=\"line\">        // or filtering.  The important part is the action, not the contents.</div><div class=\"line\">        //看注释，就是这是处理特殊case的代码</div><div class=\"line\">        final int oldAction = event.getAction();</div><div class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</div><div class=\"line\">            if (child == null) &#123;</div><div class=\"line\">                handled = super.dispatchTouchEvent(event);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handled = child.dispatchTouchEvent(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            event.setAction(oldAction);</div><div class=\"line\">            return handled;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Calculate the number of pointers to deliver.</div><div class=\"line\">        final int oldPointerIdBits = event.getPointerIdBits();</div><div class=\"line\">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class=\"line\"></div><div class=\"line\">        // If for some reason we ended up in an inconsistent state where it looks like we</div><div class=\"line\">        // might produce a motion event with no pointers in it, then drop the event.</div><div class=\"line\">        if (newPointerIdBits == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the number of pointers is the same and we don&apos;t need to perform any fancy</div><div class=\"line\">        // irreversible transformations, then we can reuse the motion event for this</div><div class=\"line\">        // dispatch as long as we are careful to revert any changes we make.</div><div class=\"line\">        // Otherwise we need to make a copy.</div><div class=\"line\">        final MotionEvent transformedEvent;</div><div class=\"line\">        //这个才是重点</div><div class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                if (child == null) &#123;</div><div class=\"line\">                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件</div><div class=\"line\">                    handled = super.dispatchTouchEvent(event);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">                    final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">                    event.offsetLocation(offsetX, offsetY);</div><div class=\"line\">\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view</div><div class=\"line\">                    handled = child.dispatchTouchEvent(event);</div><div class=\"line\"></div><div class=\"line\">                    event.offsetLocation(-offsetX, -offsetY);</div><div class=\"line\">                &#125;</div><div class=\"line\">                return handled;</div><div class=\"line\">            &#125;</div><div class=\"line\">            transformedEvent = MotionEvent.obtain(event);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            transformedEvent = event.split(newPointerIdBits);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//这里和上面同理</div><div class=\"line\">        // Perform any necessary transformations and dispatch.</div><div class=\"line\">        if (child == null) &#123;</div><div class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">            final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">            transformedEvent.offsetLocation(offsetX, offsetY);</div><div class=\"line\">            if (! child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                transformedEvent.transform(child.getInverseMatrix());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handled = child.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Done.</div><div class=\"line\">        transformedEvent.recycle();</div><div class=\"line\">        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>总结<br>我们会看到这里有三百多行代码，逻辑非常复杂，但是我们剔除一些不必要的干扰项，其实逻辑还是很清晰的</p>\n</li>\n<li><p>1、第一步，首先，对down事件进行处理，清除上次缓存的状态，在down事件里判断viewgroup是否要拦截事件，首先判断标志位FLAG_DISALLOW_INTERCEPT，<code>有这个标志位表示不允许拦截</code>，则直接进行第二步事件的分发；<code>没有标志未表示允许拦截</code>，则先调用当前viewgroup的onInterceptTouchEvent，根据onInterceptTouchEvent的值，<code>如果为true</code>，表示当前viewgroup要消费这个事件，则执行第三步，即执行该viewgroup的onTouchEvent事件;<code>如果为false</code>，则表示当前viewgroup不消费此事件，则执行第二步，对该事件进行分发。</p>\n</li>\n<li><p>2、第二步，要对事件进行分发，如果viewgroup有子view，则按照z-order顺序分发事件，首先判断事件的坐标在不在这个view里面，若是才执行子view的dispatchTouchEvent的方法，<code>若这个方法返回值为true</code>，就是有子view消费了此事件，则继续遍历（这里虽然用链表来存储接受事件的view，但是这个view每次应该只有一个，因为同一个事件只能一个view来消费，这里还需探讨？），返回true;<code>若这个方法返回值为false</code>，则一直遍历完所有的子view，最后返回false。</p>\n</li>\n</ul>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3><p>view这里的代码就少很多<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Pass the touch screen motion event down to the target view, or this</div><div class=\"line\">     * view if it is the target.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be dispatched.</div><div class=\"line\">     * @return True if the event was handled by the view, false otherwise.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">        // If the event should be handled by accessibility focus first.</div><div class=\"line\">        if (event.isTargetAccessibilityFocus()) &#123;</div><div class=\"line\">            // We don&apos;t have focus or no virtual descendant has it, do not handle the event.</div><div class=\"line\">            if (!isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // We have focus and got the event, then use normal event dispatch.</div><div class=\"line\">            event.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean result = false;</div><div class=\"line\"></div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(event, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final int actionMasked = event.getActionMasked();</div><div class=\"line\">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">            // Defensive cleanup for new gesture</div><div class=\"line\">            stopNestedScroll();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">//这里和viewgroup的一样</div><div class=\"line\">        if (onFilterTouchEventForSecurity(event)) &#123;</div><div class=\"line\">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //noinspection SimplifiableIfStatement</div><div class=\"line\">            //如果有设置onTouchListener，则执行，且返回结果标记为true，代表事件已消费</div><div class=\"line\">            ListenerInfo li = mListenerInfo;</div><div class=\"line\">            if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class=\"line\">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class=\"line\">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">//没有执行上面的onTouchListener，才会执行onTouchEvent</div><div class=\"line\">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class=\"line\">                result = true;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Clean up after nested scrolls if this is the end of a gesture;</div><div class=\"line\">        // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest</div><div class=\"line\">        // of the gesture.</div><div class=\"line\">        if (actionMasked == MotionEvent.ACTION_UP ||</div><div class=\"line\">                actionMasked == MotionEvent.ACTION_CANCEL ||</div><div class=\"line\">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</div><div class=\"line\">            stopNestedScroll();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">    * Implement this method to handle touch screen motion events.</div><div class=\"line\">    * &lt;p&gt;</div><div class=\"line\">    * If this method is used to detect click actions, it is recommended that</div><div class=\"line\">    * the actions be performed by implementing and calling</div><div class=\"line\">    * &#123;@link #performClick()&#125;. This will ensure consistent system behavior,</div><div class=\"line\">    * including:</div><div class=\"line\">    * &lt;ul&gt;</div><div class=\"line\">    * &lt;li&gt;obeying click sound preferences</div><div class=\"line\">    * &lt;li&gt;dispatching OnClickListener calls</div><div class=\"line\">    * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when</div><div class=\"line\">    * accessibility features are enabled</div><div class=\"line\">    * &lt;/ul&gt;</div><div class=\"line\">    *</div><div class=\"line\">    * @param event The motion event.</div><div class=\"line\">    * @return True if the event was handled, false otherwise.</div><div class=\"line\">    */</div><div class=\"line\">   public boolean onTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       final float x = event.getX();</div><div class=\"line\">       final float y = event.getY();</div><div class=\"line\">       final int viewFlags = mViewFlags;</div><div class=\"line\">       final int action = event.getAction();</div><div class=\"line\"></div><div class=\"line\">       if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class=\"line\">           if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class=\"line\">               setPressed(false);</div><div class=\"line\">           &#125;</div><div class=\"line\">           // A disabled view that is clickable still consumes the touch</div><div class=\"line\">           // events, it just doesn&apos;t respond to them.</div><div class=\"line\">           return (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class=\"line\">                   || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class=\"line\">                   || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (mTouchDelegate != null) &#123;</div><div class=\"line\">           if (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class=\"line\">               return true;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">//这里要注意只要这个view设置了 CLICKABLE  LONG_CLICKABLE CONTEXT_CLICKABLE这三个属相，那么返回的结果必然为true，而我们一般用到的view绝大部分默认都是设置了的（因为大部分view默认都是可以接受事件的除了View）</div><div class=\"line\">       if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class=\"line\">               (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class=\"line\">               (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class=\"line\">           switch (action) &#123;</div><div class=\"line\">               case MotionEvent.ACTION_UP:</div><div class=\"line\">                   boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</div><div class=\"line\">                   if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</div><div class=\"line\">                       // take focus if we don&apos;t have it already and we should in</div><div class=\"line\">                       // touch mode.</div><div class=\"line\">                       boolean focusTaken = false;</div><div class=\"line\">                       if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class=\"line\">                           focusTaken = requestFocus();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (prepressed) &#123;</div><div class=\"line\">                           // The button is being released before we actually</div><div class=\"line\">                           // showed it as pressed.  Make it show the pressed</div><div class=\"line\">                           // state now (before scheduling the click) to ensure</div><div class=\"line\">                           // the user sees it.</div><div class=\"line\">                           setPressed(true, x, y);</div><div class=\"line\">                      &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class=\"line\">                           // This is a tap, so remove the longpress check</div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           // Only perform take click actions if we were in the pressed state</div><div class=\"line\">                           if (!focusTaken) &#123;</div><div class=\"line\">                               // Use a Runnable and post this rather than calling</div><div class=\"line\">                               // performClick directly. This lets other visual state</div><div class=\"line\">                               // of the view update before click actions start.</div><div class=\"line\">                               if (mPerformClick == null) &#123;</div><div class=\"line\">                                   mPerformClick = new PerformClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                               if (!post(mPerformClick)) &#123;</div><div class=\"line\">                                   performClick();</div><div class=\"line\">                               &#125;</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (mUnsetPressedState == null) &#123;</div><div class=\"line\">                           mUnsetPressedState = new UnsetPressedState();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       if (prepressed) &#123;</div><div class=\"line\">                           postDelayed(mUnsetPressedState,</div><div class=\"line\">                                   ViewConfiguration.getPressedStateDuration());</div><div class=\"line\">                       &#125; else if (!post(mUnsetPressedState)) &#123;</div><div class=\"line\">                           // If the post failed, unpress right now</div><div class=\"line\">                           mUnsetPressedState.run();</div><div class=\"line\">                       &#125;</div><div class=\"line\"></div><div class=\"line\">                       removeTapCallback();</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   mIgnoreNextUpEvent = false;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_DOWN:</div><div class=\"line\">                   mHasPerformedLongPress = false;</div><div class=\"line\"></div><div class=\"line\">                   if (performButtonActionOnTouchDown(event)) &#123;</div><div class=\"line\">                       break;</div><div class=\"line\">                   &#125;</div><div class=\"line\"></div><div class=\"line\">                   // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</div><div class=\"line\">                   boolean isInScrollingContainer = isInScrollingContainer();</div><div class=\"line\"></div><div class=\"line\">                   // For views inside a scrolling container, delay the pressed feedback for</div><div class=\"line\">                   // a short period in case this is a scroll.</div><div class=\"line\">                   if (isInScrollingContainer) &#123;</div><div class=\"line\">                       mPrivateFlags |= PFLAG_PREPRESSED;</div><div class=\"line\">                       if (mPendingCheckForTap == null) &#123;</div><div class=\"line\">                           mPendingCheckForTap = new CheckForTap();</div><div class=\"line\">                       &#125;</div><div class=\"line\">                       mPendingCheckForTap.x = event.getX();</div><div class=\"line\">                       mPendingCheckForTap.y = event.getY();</div><div class=\"line\">                       postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       // Not inside a scrolling container, so show the feedback right away</div><div class=\"line\">                       setPressed(true, x, y);</div><div class=\"line\">                       checkForLongClick(0, x, y);</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_CANCEL:</div><div class=\"line\">                   setPressed(false);</div><div class=\"line\">                   removeTapCallback();</div><div class=\"line\">                   removeLongPressCallback();</div><div class=\"line\">                   mInContextButtonPress = false;</div><div class=\"line\">                   mHasPerformedLongPress = false;</div><div class=\"line\">                   mIgnoreNextUpEvent = false;</div><div class=\"line\">                   break;</div><div class=\"line\"></div><div class=\"line\">               case MotionEvent.ACTION_MOVE:</div><div class=\"line\">                   drawableHotspotChanged(x, y);</div><div class=\"line\"></div><div class=\"line\">                   // Be lenient about moving outside of buttons</div><div class=\"line\">                   if (!pointInView(x, y, mTouchSlop)) &#123;</div><div class=\"line\">                       // Outside button</div><div class=\"line\">                       removeTapCallback();</div><div class=\"line\">                       if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class=\"line\">                           // Remove any future long press/tap checks</div><div class=\"line\">                           removeLongPressCallback();</div><div class=\"line\"></div><div class=\"line\">                           setPressed(false);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   break;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           return true;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return false;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/ByteArrayInputStream/bytearrayinputstream.png","post":"cj0wf0ovm00004u2dwk375zt5","slug":"bytearrayinputstream.png","modified":1,"renderable":1},{"_id":"source/_posts/ByteArrayInputStream/fileinputstream.png","post":"cj0wf0ovm00004u2dwk375zt5","slug":"fileinputstream.png","modified":1,"renderable":1},{"_id":"source/_posts/ByteArrayInputStream/filterinputstream.png","post":"cj0wf0ovm00004u2dwk375zt5","slug":"filterinputstream.png","modified":1,"renderable":1},{"_id":"source/_posts/debug-android-source/android.jpg","post":"cj0wf0ow5000b4u2dyqb3lyq1","slug":"android.jpg","modified":1,"renderable":1},{"_id":"source/_posts/debug-android-source/error.png","post":"cj0wf0ow5000b4u2dyqb3lyq1","slug":"error.png","modified":1,"renderable":1},{"_id":"source/_posts/debug-android-source/right.png","post":"cj0wf0ow5000b4u2dyqb3lyq1","slug":"right.png","modified":1,"renderable":1},{"_id":"source/_posts/debug-android-source/sdk_manager.png","post":"cj0wf0ow5000b4u2dyqb3lyq1","slug":"sdk_manager.png","modified":1,"renderable":1},{"_id":"source/_posts/loopviewpager/final.png","post":"cj0wf0owb000g4u2dvpg7pic7","slug":"final.png","modified":1,"renderable":1},{"_id":"source/_posts/loopviewpager/mdify.png","post":"cj0wf0owb000g4u2dvpg7pic7","slug":"mdify.png","modified":1,"renderable":1},{"_id":"source/_posts/loopviewpager/modify2.png","post":"cj0wf0owb000g4u2dvpg7pic7","slug":"modify2.png","modified":1,"renderable":1},{"_id":"source/_posts/loopviewpager/origin.png","post":"cj0wf0owb000g4u2dvpg7pic7","slug":"origin.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/file.jpg","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"file.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/inputstream.png","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"inputstream.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/outputstream.png","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"outputstream.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/reader.png","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"reader.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/socket.jpg","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"socket.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java-IO/writer.png","post":"cj0wf0ovs00024u2dofxwyw7x","slug":"writer.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj0wf0ovm00004u2dwk375zt5","category_id":"cj0wf0ovu00034u2db8mzoerx","_id":"cj0wf0ow9000c4u2dbigeokvt"},{"post_id":"cj0wf0ovs00024u2dofxwyw7x","category_id":"cj0wf0ow300084u2dobw3dxxw","_id":"cj0wf0owg000j4u2d9nk57rbh"},{"post_id":"cj0wf0ovw00054u2d10d1dhgo","category_id":"cj0wf0owa000e4u2dn6tac8dt","_id":"cj0wf0owj000p4u2d2iehqbrk"},{"post_id":"cj0wf0ovz00064u2d7o2e2t4u","category_id":"cj0wf0owg000k4u2ddbzayf20","_id":"cj0wf0owl000t4u2dywqrcmf9"},{"post_id":"cj0wf0ow200074u2dqvb9jci0","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0own000x4u2dhznk1x79"},{"post_id":"cj0wf0ow5000b4u2dyqb3lyq1","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0own00114u2d3ncr42ni"},{"post_id":"cj0wf0owa000d4u2dk39gcd0x","category_id":"cj0wf0own000y4u2dallq9km3","_id":"cj0wf0owo00154u2d37xd5emg"},{"post_id":"cj0wf0owb000g4u2dvpg7pic7","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0owp00194u2ddnk16l8a"},{"post_id":"cj0wf0owf000i4u2d95y491h3","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0owr001d4u2dezkbzpkw"},{"post_id":"cj0wf0owh000m4u2d3h3661nb","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0owt001h4u2db5dpd9qo"},{"post_id":"cj0wf0owi000o4u2di3vlqnqy","category_id":"cj0wf0owj000q4u2dgtlzi7um","_id":"cj0wf0owt001j4u2dzs9kn7ci"}],"PostTag":[{"post_id":"cj0wf0ovm00004u2dwk375zt5","tag_id":"cj0wf0ovw00044u2dmjj8l8o3","_id":"cj0wf0ow5000a4u2d74hl6clq"},{"post_id":"cj0wf0ovs00024u2dofxwyw7x","tag_id":"cj0wf0ow400094u2da8kqursy","_id":"cj0wf0owd000h4u2dahthugls"},{"post_id":"cj0wf0ovw00054u2d10d1dhgo","tag_id":"cj0wf0owb000f4u2d24k61v05","_id":"cj0wf0owi000n4u2dgpv0fxx8"},{"post_id":"cj0wf0ovz00064u2d7o2e2t4u","tag_id":"cj0wf0owg000l4u2dln8981b3","_id":"cj0wf0owk000s4u2d9y5l9wmq"},{"post_id":"cj0wf0ow200074u2dqvb9jci0","tag_id":"cj0wf0owk000r4u2dazh13lis","_id":"cj0wf0owm000w4u2d8yl8lo1o"},{"post_id":"cj0wf0ow5000b4u2dyqb3lyq1","tag_id":"cj0wf0owl000v4u2dipoj4xvn","_id":"cj0wf0own00104u2da076rwnr"},{"post_id":"cj0wf0owa000d4u2dk39gcd0x","tag_id":"cj0wf0own000z4u2dqhn11z3j","_id":"cj0wf0owo00144u2dzrinji5b"},{"post_id":"cj0wf0owb000g4u2dvpg7pic7","tag_id":"cj0wf0owl000v4u2dipoj4xvn","_id":"cj0wf0owp00184u2d1o2tyivv"},{"post_id":"cj0wf0owf000i4u2d95y491h3","tag_id":"cj0wf0owl000v4u2dipoj4xvn","_id":"cj0wf0owr001c4u2dju35no3s"},{"post_id":"cj0wf0owh000m4u2d3h3661nb","tag_id":"cj0wf0owl000v4u2dipoj4xvn","_id":"cj0wf0ows001g4u2dczuhbdzp"},{"post_id":"cj0wf0owi000o4u2di3vlqnqy","tag_id":"cj0wf0owl000v4u2dipoj4xvn","_id":"cj0wf0owt001i4u2dmg035k47"}],"Tag":[{"name":"Java","_id":"cj0wf0ovw00044u2dmjj8l8o3"},{"name":"Java,I/O","_id":"cj0wf0ow400094u2da8kqursy"},{"name":"TensorFlow,Android","_id":"cj0wf0owb000f4u2d24k61v05"},{"name":"Ubuntu","_id":"cj0wf0owg000l4u2dln8981b3"},{"name":"Ubuntu,Android","_id":"cj0wf0owk000r4u2dazh13lis"},{"name":"Android","_id":"cj0wf0owl000v4u2dipoj4xvn"},{"name":"git","_id":"cj0wf0own000z4u2dqhn11z3j"}]}}