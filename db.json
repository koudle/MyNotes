{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/sass/component/prev-net.scss","path":"sass/component/prev-net.scss","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1486187677000},{"_id":"themes/fexo/.gitignore","hash":"32223fbe296f8e3026c689bad8f3dea9d0fcbb43","modified":1486187677000},{"_id":"themes/fexo/LICENSE","hash":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1486187677000},{"_id":"themes/fexo/_config.yml","hash":"6e10654001d37a9b7af6ad6a27d439f003017c48","modified":1488094732178},{"_id":"themes/fexo/README.md","hash":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1486187677000},{"_id":"themes/fexo/gulpfile.js","hash":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1486187677000},{"_id":"themes/fexo/package.json","hash":"351b5b21f5ea8851103ee1891248be43f3c27027","modified":1486187677000},{"_id":"source/_posts/ByteArrayInputStream.md","hash":"25cf9f17972ee959a03065fb6ebe2d584e3c7213","modified":1488290735476},{"_id":"source/_posts/Java-IO.md","hash":"27dc430491e1b3fa4b5190e6f86e81dc226a3d75","modified":1488203282783},{"_id":"source/_posts/TensorFlow.md","hash":"8eb3379b2fb939bb15235de8473e03f3a76aaa43","modified":1488100891052},{"_id":"source/_posts/viewpager-webview.md","hash":"55936f2609aff328d0db9bacfa28ee9f370ea096","modified":1489154501246},{"_id":"source/_posts/Ubuntu-Android-NDK.md","hash":"fd82bd4d8a3e111e529dce22843b6b308b5588df","modified":1488100282469},{"_id":"source/_posts/Ubuntun-set-environment.md","hash":"837dc4ebf15f8aca9b876f89b42ac1436d91545e","modified":1488098282343},{"_id":"source/about/index.md","hash":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1488094068052},{"_id":"source/project/index.md","hash":"fdf7ecc245ccfc593aa5b10cfb58ca003f600420","modified":1488094068052},{"_id":"source/category/index.md","hash":"e599870f1d023dfddd75e5e89fd1724b6b12aa74","modified":1488094068052},{"_id":"source/tag/index.md","hash":"7de81a09ff31847ac8131fac8ab7a0ebe1466ad8","modified":1488094068052},{"_id":"themes/fexo/languages/default.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1486187677000},{"_id":"themes/fexo/languages/en.yml","hash":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1486187677000},{"_id":"themes/fexo/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1486187677000},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1486187677000},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1486187677000},{"_id":"themes/fexo/layout/about.ejs","hash":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1486187677000},{"_id":"themes/fexo/layout/archive.ejs","hash":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1486187677000},{"_id":"themes/fexo/layout/category.ejs","hash":"6d7f43a3d3180e7eb120601bae701664911cf8e6","modified":1486187677000},{"_id":"themes/fexo/layout/index.ejs","hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1486187677000},{"_id":"themes/fexo/layout/layout.ejs","hash":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1486187677000},{"_id":"themes/fexo/layout/link.ejs","hash":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1486187677000},{"_id":"themes/fexo/layout/post.ejs","hash":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1486187677000},{"_id":"themes/fexo/layout/project.ejs","hash":"6648041e1319c8ee3e16c882b33bb457c67a9527","modified":1486187677000},{"_id":"themes/fexo/layout/search.ejs","hash":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1486187677000},{"_id":"themes/fexo/layout/tag.ejs","hash":"2cadf0acdf7c8e76bd4f27c6d7fe97eefe42ef5e","modified":1486187677000},{"_id":"source/_posts/ByteArrayInputStream/bytearrayinputstream.png","hash":"aa59865c33dc709e165e71648023bc1d10727bac","modified":1488285825076},{"_id":"source/_posts/ByteArrayInputStream/fileinputstream.png","hash":"79c7af044556b5e06f9f41eeec6d1cbb2ec9502c","modified":1488287086478},{"_id":"source/_posts/ByteArrayInputStream/filterinputstream.png","hash":"6c54a4b8ca42bcf6a7f99fb8b74713443a8d3e78","modified":1488290155013},{"_id":"source/_posts/Java-IO/file.jpg","hash":"16336b5cb2d6f7289d3eb4b3f907d5c01c6cb086","modified":1488202668088},{"_id":"source/_posts/Java-IO/inputstream.png","hash":"6f20a0c7618b3450ec0d72b7963d4e4e5694866c","modified":1488200975016},{"_id":"source/_posts/Java-IO/outputstream.png","hash":"82e721832ed52195efadd4234ce0b9c6aa86d302","modified":1488202266022},{"_id":"source/_posts/Java-IO/reader.png","hash":"5f98479726b09c0891339a954bbe2805dc956912","modified":1488202477846},{"_id":"source/_posts/Java-IO/socket.jpg","hash":"e4443287e9fda0a9590ff0fd6db152b82a3d7f6c","modified":1488202905676},{"_id":"source/_posts/Java-IO/writer.png","hash":"e1654dde9d608d741725ee21810a98ae561d520b","modified":1488202466944},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"ab0adc8f18a96eab18bb584233c0e8d4ddba71fc","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1486187677000},{"_id":"themes/fexo/source/css/styles.css","hash":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1486187677000},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1486187677000},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"82847252dc8b5408437a50a35f07b4fcbc240335","modified":1487837802788},{"_id":"themes/fexo/source/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1486187677000},{"_id":"themes/fexo/source/js/bundle.js","hash":"7da160b15a43ce19273ec85204828bd42628546f","modified":1486187677000},{"_id":"themes/fexo/source/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1486187677000},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1486187677000},{"_id":"themes/fexo/source/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1486187677000},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1486187677000},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1486187677000},{"_id":"themes/fexo/source/sass/_base.scss","hash":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1486187677000},{"_id":"themes/fexo/source/sass/_common.scss","hash":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1486187677000},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1486187677000},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"10e188d379782ae2ee10427544919557036d0137","modified":1486187677000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1486187677000},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1486187677000},{"_id":"themes/fexo/source/sass/_type.scss","hash":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1486187677000},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1486187677000},{"_id":"themes/fexo/source/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1486187677000},{"_id":"themes/fexo/source/css/styles.css.map","hash":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"043ed1e5625860696fe42bb88c998668faf71449","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"65bf93ad8e149033e6f93d673cc85ee223615589","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/duoshuo.ejs","hash":"b732200315e4c82e92bc7bd0ad33eb171d246e26","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1486187677000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1486187677000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1486187677000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"172a3d5f747ba028d7e10e6f03ebc1db4d487a54","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/prev-net.scss","hash":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1486187677000},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"bcbaded3d378bbaa1497f4c3843994ea589f3149","modified":1486187677000},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1486187677000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1486187677000},{"_id":"public/about/index.html","hash":"b80e5f38c4c7d0168911878d205afabfc6893dba","modified":1489154509790},{"_id":"public/tag/index.html","hash":"8f40023459d1936001a9defcaf9d2f45c4c50f9c","modified":1489154509812},{"_id":"public/category/index.html","hash":"514ad4d950bbb238d6cae4c76e0e889208bc2db3","modified":1489154509812},{"_id":"public/project/index.html","hash":"e7d6548ed1635da28f5852571b2e496bffb59d00","modified":1489154509810},{"_id":"public/2017/02/26/Ubuntu-Android-NDK/index.html","hash":"a5c68f8da6c54073218ecf646fcbb67e48707cf7","modified":1489154509812},{"_id":"public/2017/02/26/Ubuntun-set-environment/index.html","hash":"e0575206d8921db39895b4e2960c3c51e5686299","modified":1489154509812},{"_id":"public/2017/02/26/TensorFlow/index.html","hash":"462b53c921712ea5348e3c80627799e7ff1c8bad","modified":1489154509812},{"_id":"public/categories/Android/index.html","hash":"f7338a4cc74b7d560e4627837a55bcce89292610","modified":1489154509814},{"_id":"public/categories/Java/index.html","hash":"a2da43c6ec51dffab8d54c65afd0258b929120ab","modified":1489154509814},{"_id":"public/categories/Java-I-O/index.html","hash":"21be48931b6e66eee853d5746edb3e554699ed11","modified":1489154509814},{"_id":"public/categories/TensorFlow-Android/index.html","hash":"b273b1c73cbaefdc9f80cdde878936b4cf5b3903","modified":1489154509814},{"_id":"public/categories/Ubuntu/index.html","hash":"58ea82843d718aa6f8d194388e5a36aef25739af","modified":1489154509814},{"_id":"public/archives/index.html","hash":"fd9bb5b4259f0a86d02e22f17a81af9649212b3d","modified":1489154509812},{"_id":"public/index.html","hash":"bc3a3dec4effb972216040b3cb37e0a4f20e3f5f","modified":1489154509812},{"_id":"public/archives/2017/index.html","hash":"3c6c8546cc10d6424d5f351a381d2f4dd5144334","modified":1489154509812},{"_id":"public/tags/Java/index.html","hash":"e8fa3989b50d76b7104b10d06c69937fe93e4613","modified":1489154509812},{"_id":"public/archives/2017/02/index.html","hash":"9acbf901b6e787bd273db833560a9b6c574e93ce","modified":1489154509812},{"_id":"public/tags/Java-I-O/index.html","hash":"082c2f15df95ca634cf51c74143dffb819436586","modified":1489154509813},{"_id":"public/tags/TensorFlow-Android/index.html","hash":"e3e27ccaa374525e320e85970a35a1899b29250e","modified":1489154509813},{"_id":"public/tags/Ubuntu-Android/index.html","hash":"b10d9bed822a99d3ad617f416f233edb29225572","modified":1489154509813},{"_id":"public/tags/Ubuntu/index.html","hash":"0037822318c552c0f5d8681f21194ef1af6e1675","modified":1489154509813},{"_id":"public/2017/02/28/ByteArrayInputStream/index.html","hash":"0b6e2c2511f0c4b2441587414bb0b4c50ee55c55","modified":1489154509814},{"_id":"public/2017/02/27/Java-IO/index.html","hash":"be6099e23f99dbfebb4c7990e4869aeb43abbd46","modified":1489154509814},{"_id":"public/2017/03/01/viewpager-webview/index.html","hash":"7453dbe192d551c5747df699b7fa0f9108292ff6","modified":1488374775130},{"_id":"public/archives/2017/03/index.html","hash":"282febe77c8070eabf97a8b7a2e5ee7a44ccba6e","modified":1489154509812},{"_id":"public/tags/Android/index.html","hash":"2e2d782a859ce231f5c655c3f227e055bc6c9a83","modified":1489154509813},{"_id":"public/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1488374775130},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1488374775130},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1488374775130},{"_id":"public/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1488374775130},{"_id":"public/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1488374775130},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1488374775130},{"_id":"public/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1488374775130},{"_id":"public/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1488374775130},{"_id":"public/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1488374775130},{"_id":"public/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1488374775130},{"_id":"public/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1488374775131},{"_id":"public/images/avatar.jpg","hash":"82847252dc8b5408437a50a35f07b4fcbc240335","modified":1488374775131},{"_id":"public/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1488374775131},{"_id":"public/sass/component/prev-net.scss","hash":"2a5befab6cef93c9023a548422d5af4ab614f84d","modified":1488374775132},{"_id":"public/2017/02/27/Java-IO/file.jpg","hash":"16336b5cb2d6f7289d3eb4b3f907d5c01c6cb086","modified":1488374775136},{"_id":"public/2017/02/27/Java-IO/inputstream.png","hash":"6f20a0c7618b3450ec0d72b7963d4e4e5694866c","modified":1488374775136},{"_id":"public/2017/02/27/Java-IO/outputstream.png","hash":"82e721832ed52195efadd4234ce0b9c6aa86d302","modified":1488374775137},{"_id":"public/2017/02/27/Java-IO/reader.png","hash":"5f98479726b09c0891339a954bbe2805dc956912","modified":1488374775137},{"_id":"public/2017/02/27/Java-IO/socket.jpg","hash":"e4443287e9fda0a9590ff0fd6db152b82a3d7f6c","modified":1488374775138},{"_id":"public/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png","hash":"aa59865c33dc709e165e71648023bc1d10727bac","modified":1488374775138},{"_id":"public/2017/02/27/Java-IO/writer.png","hash":"e1654dde9d608d741725ee21810a98ae561d520b","modified":1488374775138},{"_id":"public/2017/02/28/ByteArrayInputStream/fileinputstream.png","hash":"79c7af044556b5e06f9f41eeec6d1cbb2ec9502c","modified":1488374775138},{"_id":"public/2017/02/28/ByteArrayInputStream/filterinputstream.png","hash":"6c54a4b8ca42bcf6a7f99fb8b74713443a8d3e78","modified":1488374775138},{"_id":"public/css/styles.css.map","hash":"8153b0247617810c1333dbd40840975e0b966ecb","modified":1488374775138},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1488374775138},{"_id":"public/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1488374775144},{"_id":"public/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1488374775144},{"_id":"public/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1488374775145},{"_id":"public/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1488374775145},{"_id":"public/js/bundle.js","hash":"7da160b15a43ce19273ec85204828bd42628546f","modified":1488374775145},{"_id":"public/css/styles.css","hash":"c4d6a1f5403cf2fe2674ba82eb2b32b0fd7dfdb8","modified":1488374775145},{"_id":"public/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1488374775145},{"_id":"public/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1488374775145},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1488374775145},{"_id":"public/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1488374775152},{"_id":"public/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1488374775152},{"_id":"public/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1488374775153},{"_id":"public/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1488374775156},{"_id":"public/2017/03/08/viewpager-webview/index.html","hash":"b3ff3073b4cfafb43351ac0d9147bb201ff072f5","modified":1488979509770},{"_id":"public/2017/03/09/viewpager-webview/index.html","hash":"eb95ec606fbfb0a580e9c3557d50db5554699788","modified":1489069467130},{"_id":"public/2017/03/10/viewpager-webview/index.html","hash":"9bd0c7bf3d9bfbd3f02ae34f7be1ea58507b13b2","modified":1489154509817}],"Category":[{"name":"Java","_id":"cizqzwtvt00045h2dsv62tmuy"},{"name":"Java,I/O","_id":"cizqzwtw8000b5h2disx3qwcj"},{"name":"TensorFlow,Android","_id":"cizqzwtwb000g5h2dqrqlq9sk"},{"name":"Android","_id":"cizqzwtwc000k5h2di4h799en"},{"name":"Ubuntu","_id":"cizqzwtwj000s5h2d5tdsapq6"}],"Data":[],"Page":[{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"about/index.html","_id":"cizqzwtvp00015h2dri3705pt","content":"","excerpt":"","more":""},{"title":"project","layout":"project","comments":0,"_content":"","source":"project/index.md","raw":"---\ntitle: project\nlayout: project\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"project/index.html","_id":"cizqzwtvs00035h2dvw4y5q5d","content":"","excerpt":"","more":""},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle:  category\nlayout:  category\ncomments: false\n---\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"category/index.html","_id":"cizqzwtvz00075h2dsol5d33m","content":"","excerpt":"","more":""},{"title":"tag","layout":"tag","comments":0,"_content":"\n","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n\n","date":"2017-02-26T07:27:48.052Z","updated":"2017-02-26T07:27:48.052Z","path":"tag/index.html","_id":"cizqzwtw600095h2dd89mda2n","content":"","excerpt":"","more":""}],"Post":[{"title":"Java I/O系列之InputStream","_content":"## 1.ByteArrayInputStream\nByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。\n\n### 1.1 结构\n{% asset_img bytearrayinputstream.png ByteArrayInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从此输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public void mark(int read)|设置流中的当前标记位置。|\n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n \n 注意：\n\n* new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区\n* ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)\n \n## 2.FileInputStream\nFileInputStream是文件输入流，用于读取文件中的字节。\n\n### 2.1结构\n{% asset_img fileinputstream.png FileInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n|public final FileDescriptor getFD() ||\n|public FileChannel getChannel()||\n\n## 3.FilterInputStream\nFilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。\n\n* BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。\n\n* DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。\n\n* PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。\n\n### 3.1 结构\n{% asset_img filterinputstream.png FilterInputStream的结构图 %}\n\n## 4.ObjectInputStream\nObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。\n\nObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。\n\nObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.\n\n```\n需要实现 java.io.Serializable 或 java.io.Externalizable的接口 \n```\n## 5.PipedInputStream\n在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。\n","source":"_posts/ByteArrayInputStream.md","raw":"---\ntitle: Java I/O系列之InputStream\ncategories: Java\ntags: Java\n---\n## 1.ByteArrayInputStream\nByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。\n\n### 1.1 结构\n{% asset_img bytearrayinputstream.png ByteArrayInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从此输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public void mark(int read)|设置流中的当前标记位置。|\n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n \n 注意：\n\n* new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区\n* ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)\n \n## 2.FileInputStream\nFileInputStream是文件输入流，用于读取文件中的字节。\n\n### 2.1结构\n{% asset_img fileinputstream.png FileInputStream结构图 %}\n\n|方法|描述| \n|--|--|\n|public int read()|从输入流中读取下一个数据字节。|\n|public int read(byte[] r, int off, int len)|将最多 len 个数据字节从此输入流读入字节数组。|\n|public int available()|返回可不发生阻塞地从此输入流读取的字节数。| \n|public long skip(long n)|从此输入流中跳过 n 个输入字节。|\n|public final FileDescriptor getFD() ||\n|public FileChannel getChannel()||\n\n## 3.FilterInputStream\nFilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。\n\n* BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。\n\n* DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。\n\n* PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。\n\n### 3.1 结构\n{% asset_img filterinputstream.png FilterInputStream的结构图 %}\n\n## 4.ObjectInputStream\nObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。\n\nObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。\n\nObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.\n\n```\n需要实现 java.io.Serializable 或 java.io.Externalizable的接口 \n```\n## 5.PipedInputStream\n在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。\n","slug":"ByteArrayInputStream","published":1,"date":"2017-02-28T14:05:35.476Z","updated":"2017-02-28T14:05:35.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqzwtvk00005h2d0m0xrz5y","content":"<h2 id=\"1-ByteArrayInputStream\"><a href=\"#1-ByteArrayInputStream\" class=\"headerlink\" title=\"1.ByteArrayInputStream\"></a>1.ByteArrayInputStream</h2><p>ByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。</p>\n<h3 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png\" alt=\"ByteArrayInputStream结构图\" title=\"ByteArrayInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从此输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public void mark(int read)</td>\n<td>设置流中的当前标记位置。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n</tbody>\n</table>\n<p> 注意：</p>\n<ul>\n<li>new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区</li>\n<li>ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)</li>\n</ul>\n<h2 id=\"2-FileInputStream\"><a href=\"#2-FileInputStream\" class=\"headerlink\" title=\"2.FileInputStream\"></a>2.FileInputStream</h2><p>FileInputStream是文件输入流，用于读取文件中的字节。</p>\n<h3 id=\"2-1结构\"><a href=\"#2-1结构\" class=\"headerlink\" title=\"2.1结构\"></a>2.1结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/fileinputstream.png\" alt=\"FileInputStream结构图\" title=\"FileInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n<tr>\n<td>public final FileDescriptor getFD()</td>\n<td></td>\n</tr>\n<tr>\n<td>public FileChannel getChannel()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-FilterInputStream\"><a href=\"#3-FilterInputStream\" class=\"headerlink\" title=\"3.FilterInputStream\"></a>3.FilterInputStream</h2><p>FilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。</p>\n<ul>\n<li><p>BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。</p>\n</li>\n<li><p>DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>\n</li>\n<li><p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n</li>\n</ul>\n<h3 id=\"3-1-结构\"><a href=\"#3-1-结构\" class=\"headerlink\" title=\"3.1 结构\"></a>3.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/filterinputstream.png\" alt=\"FilterInputStream的结构图\" title=\"FilterInputStream的结构图\">\n<h2 id=\"4-ObjectInputStream\"><a href=\"#4-ObjectInputStream\" class=\"headerlink\" title=\"4.ObjectInputStream\"></a>4.ObjectInputStream</h2><p>ObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。</p>\n<p>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。</p>\n<p>ObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">需要实现 java.io.Serializable 或 java.io.Externalizable的接口</div></pre></td></tr></table></figure>\n<h2 id=\"5-PipedInputStream\"><a href=\"#5-PipedInputStream\" class=\"headerlink\" title=\"5.PipedInputStream\"></a>5.PipedInputStream</h2><p>在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>\n","excerpt":"","more":"<h2 id=\"1-ByteArrayInputStream\"><a href=\"#1-ByteArrayInputStream\" class=\"headerlink\" title=\"1.ByteArrayInputStream\"></a>1.ByteArrayInputStream</h2><p>ByteArrayInputStream是字节数组输入流，用于在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在字节数组的缓冲区中。</p>\n<h3 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/bytearrayinputstream.png\" alt=\"ByteArrayInputStream结构图\" title=\"ByteArrayInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从此输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public void mark(int read)</td>\n<td>设置流中的当前标记位置。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n</tbody>\n</table>\n<p> 注意：</p>\n<ul>\n<li>new一个ByteArrayInputStream的对象，需要一个byte数组作为缓冲区</li>\n<li>ByteArrayInputStream的close方法为空，所以关闭ByteArrayInputStream无效，因此此类的方法在关闭此流后仍可调用，而不会抛异常(IOException)</li>\n</ul>\n<h2 id=\"2-FileInputStream\"><a href=\"#2-FileInputStream\" class=\"headerlink\" title=\"2.FileInputStream\"></a>2.FileInputStream</h2><p>FileInputStream是文件输入流，用于读取文件中的字节。</p>\n<h3 id=\"2-1结构\"><a href=\"#2-1结构\" class=\"headerlink\" title=\"2.1结构\"></a>2.1结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/fileinputstream.png\" alt=\"FileInputStream结构图\" title=\"FileInputStream结构图\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public int read()</td>\n<td>从输入流中读取下一个数据字节。</td>\n</tr>\n<tr>\n<td>public int read(byte[] r, int off, int len)</td>\n<td>将最多 len 个数据字节从此输入流读入字节数组。</td>\n</tr>\n<tr>\n<td>public int available()</td>\n<td>返回可不发生阻塞地从此输入流读取的字节数。</td>\n</tr>\n<tr>\n<td>public long skip(long n)</td>\n<td>从此输入流中跳过 n 个输入字节。</td>\n</tr>\n<tr>\n<td>public final FileDescriptor getFD()</td>\n<td></td>\n</tr>\n<tr>\n<td>public FileChannel getChannel()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-FilterInputStream\"><a href=\"#3-FilterInputStream\" class=\"headerlink\" title=\"3.FilterInputStream\"></a>3.FilterInputStream</h2><p>FilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有InflaterInputStream、BufferedInputStream、DataInputStream和PrintStream。</p>\n<ul>\n<li><p>BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。</p>\n</li>\n<li><p>DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>\n</li>\n<li><p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n</li>\n</ul>\n<h3 id=\"3-1-结构\"><a href=\"#3-1-结构\" class=\"headerlink\" title=\"3.1 结构\"></a>3.1 结构</h3><img src=\"/2017/02/28/ByteArrayInputStream/filterinputstream.png\" alt=\"FilterInputStream的结构图\" title=\"FilterInputStream的结构图\">\n<h2 id=\"4-ObjectInputStream\"><a href=\"#4-ObjectInputStream\" class=\"headerlink\" title=\"4.ObjectInputStream\"></a>4.ObjectInputStream</h2><p>ObjectInputStream用来序列化。ObjectInputStream 确保从流创建的图形中所有对象的类型与 Java 虚拟机中的显示的类相匹配。使用标准机制按需加载类。</p>\n<p>ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久性存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。</p>\n<p>ObjectOutputStream可以把对象直接存入到文件中,然后利用ObjectInputStream读取文件还原成对象,前提是该对象实现了Serializable接口.由于ObjectInputStream无法判断文件流中对象的数量,所以我们在循环读取的时候,只好写个死循环,然后捕捉EOFException异常,来实现把所有对象读进来.也可以在写入文件时,把所有对象存进ArrayList,然后把这个ArrayList写入文件,这样就不需要判断对象数量了.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">需要实现 java.io.Serializable 或 java.io.Externalizable的接口</div></pre></td></tr></table></figure>\n<h2 id=\"5-PipedInputStream\"><a href=\"#5-PipedInputStream\" class=\"headerlink\" title=\"5.PipedInputStream\"></a>5.PipedInputStream</h2><p>在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>\n"},{"title":"Java I/O 系列第一篇","_content":"## 1.前言\n讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：\n\n* 图片库\n* SharedPreferences\n\n还有一些应用场景：\n\n* 序列化与反序列化\n\n## 2.Java 的 I/O 类库的基本架构\nJava 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：\n\n* 基于字节操作的 I/O 接口：InputStream 和 OutputStream\n* 基于字符操作的 I/O 接口：Writer 和 Reader\n* 基于磁盘操作的 I/O 接口：File\n* 基于网络操作的 I/O 接口：Socket\n\n前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。\n\n### 2.1 基于字节操作的 I/O 接口\n基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。\n{% asset_img inputstream.png  InputStream 相关类层次结构%}\n\n{% asset_img outputstream.png OutputStream%}\n\n### 2.2基于字符的 I/O 操作接口\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。\n{% asset_img reader.png Reader相关类层次结构 %}\n\n{% asset_img writer.png Writer相关类层次结构 %}\n\n### 2.3 基于磁盘操作的 I/O 接口\n前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。\n\n我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。\n何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：\n{% asset_img file.jpg 从磁盘读取文件%}\n\n### 2.4基于网络操作的 I/O 接口\nSocket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。\n下图是典型的基于 Socket 的通信的场景：\n\n{% asset_img socket.jpg Socket 通信示例 %}\n\n\n主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。\n#### 建立通信链路\n当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。\n与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。\n#### 数据传输\n传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。\n当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。","source":"_posts/Java-IO.md","raw":"---\ntitle: Java I/O 系列第一篇\ncategories: Java,I/O\ntags: Java,I/O\n---\n## 1.前言\n讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：\n\n* 图片库\n* SharedPreferences\n\n还有一些应用场景：\n\n* 序列化与反序列化\n\n## 2.Java 的 I/O 类库的基本架构\nJava 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：\n\n* 基于字节操作的 I/O 接口：InputStream 和 OutputStream\n* 基于字符操作的 I/O 接口：Writer 和 Reader\n* 基于磁盘操作的 I/O 接口：File\n* 基于网络操作的 I/O 接口：Socket\n\n前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。\n\n### 2.1 基于字节操作的 I/O 接口\n基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。\n{% asset_img inputstream.png  InputStream 相关类层次结构%}\n\n{% asset_img outputstream.png OutputStream%}\n\n### 2.2基于字符的 I/O 操作接口\n不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。\n{% asset_img reader.png Reader相关类层次结构 %}\n\n{% asset_img writer.png Writer相关类层次结构 %}\n\n### 2.3 基于磁盘操作的 I/O 接口\n前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。\n\n我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。\n何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。\n\n下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：\n{% asset_img file.jpg 从磁盘读取文件%}\n\n### 2.4基于网络操作的 I/O 接口\nSocket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。\n下图是典型的基于 Socket 的通信的场景：\n\n{% asset_img socket.jpg Socket 通信示例 %}\n\n\n主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。\n#### 建立通信链路\n当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。\n与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。\n#### 数据传输\n传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。\n当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。","slug":"Java-IO","published":1,"date":"2017-02-27T13:48:02.783Z","updated":"2017-02-27T13:48:02.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqzwtvq00025h2dycpwkcrv","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：</p>\n<ul>\n<li>图片库</li>\n<li>SharedPreferences</li>\n</ul>\n<p>还有一些应用场景：</p>\n<ul>\n<li>序列化与反序列化</li>\n</ul>\n<h2 id=\"2-Java-的-I-O-类库的基本架构\"><a href=\"#2-Java-的-I-O-类库的基本架构\" class=\"headerlink\" title=\"2.Java 的 I/O 类库的基本架构\"></a>2.Java 的 I/O 类库的基本架构</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p>\n<ul>\n<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>\n<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>\n<li>基于磁盘操作的 I/O 接口：File</li>\n<li>基于网络操作的 I/O 接口：Socket</li>\n</ul>\n<p>前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。</p>\n<h3 id=\"2-1-基于字节操作的-I-O-接口\"><a href=\"#2-1-基于字节操作的-I-O-接口\" class=\"headerlink\" title=\"2.1 基于字节操作的 I/O 接口\"></a>2.1 基于字节操作的 I/O 接口</h3><p>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。<br><img src=\"/2017/02/27/Java-IO/inputstream.png\" alt=\"InputStream 相关类层次结构\" title=\"InputStream 相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/outputstream.png\" alt=\"OutputStream\" title=\"OutputStream\">\n<h3 id=\"2-2基于字符的-I-O-操作接口\"><a href=\"#2-2基于字符的-I-O-操作接口\" class=\"headerlink\" title=\"2.2基于字符的 I/O 操作接口\"></a>2.2基于字符的 I/O 操作接口</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。<br><img src=\"/2017/02/27/Java-IO/reader.png\" alt=\"Reader相关类层次结构\" title=\"Reader相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/writer.png\" alt=\"Writer相关类层次结构\" title=\"Writer相关类层次结构\">\n<h3 id=\"2-3-基于磁盘操作的-I-O-接口\"><a href=\"#2-3-基于磁盘操作的-I-O-接口\" class=\"headerlink\" title=\"2.3 基于磁盘操作的 I/O 接口\"></a>2.3 基于磁盘操作的 I/O 接口</h3><p>前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。</p>\n<p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。<br>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<p>下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：<br><img src=\"/2017/02/27/Java-IO/file.jpg\" alt=\"从磁盘读取文件\" title=\"从磁盘读取文件\"></p>\n<h3 id=\"2-4基于网络操作的-I-O-接口\"><a href=\"#2-4基于网络操作的-I-O-接口\" class=\"headerlink\" title=\"2.4基于网络操作的 I/O 接口\"></a>2.4基于网络操作的 I/O 接口</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。<br>下图是典型的基于 Socket 的通信的场景：</p>\n<img src=\"/2017/02/27/Java-IO/socket.jpg\" alt=\"Socket 通信示例\" title=\"Socket 通信示例\">\n<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>\n<h4 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h4><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。<br>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p>\n<h4 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h4><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。<br>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p>\n","excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>讲一讲Java I/O的一些事情。因为I/O问题很容易出现性能瓶颈，但我们在具体的开发过程中，却很少涉及到I/O之类的操作,那是因为涉及到的大部分I/O操作都被封装了起来，不被我们所感知，如：</p>\n<ul>\n<li>图片库</li>\n<li>SharedPreferences</li>\n</ul>\n<p>还有一些应用场景：</p>\n<ul>\n<li>序列化与反序列化</li>\n</ul>\n<h2 id=\"2-Java-的-I-O-类库的基本架构\"><a href=\"#2-Java-的-I-O-类库的基本架构\" class=\"headerlink\" title=\"2.Java 的 I/O 类库的基本架构\"></a>2.Java 的 I/O 类库的基本架构</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p>\n<ul>\n<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li>\n<li>基于字符操作的 I/O 接口：Writer 和 Reader</li>\n<li>基于磁盘操作的 I/O 接口：File</li>\n<li>基于网络操作的 I/O 接口：Socket</li>\n</ul>\n<p>前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，虽然 Socket 类并不在 java.io 包下，但是我仍然把它们划分在一起。</p>\n<h3 id=\"2-1-基于字节操作的-I-O-接口\"><a href=\"#2-1-基于字节操作的-I-O-接口\" class=\"headerlink\" title=\"2.1 基于字节操作的 I/O 接口\"></a>2.1 基于字节操作的 I/O 接口</h3><p>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream。<br><img src=\"/2017/02/27/Java-IO/inputstream.png\" alt=\"InputStream 相关类层次结构\" title=\"InputStream 相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/outputstream.png\" alt=\"OutputStream\" title=\"OutputStream\">\n<h3 id=\"2-2基于字符的-I-O-操作接口\"><a href=\"#2-2基于字符的-I-O-操作接口\" class=\"headerlink\" title=\"2.2基于字符的 I/O 操作接口\"></a>2.2基于字符的 I/O 操作接口</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为啥有操作字符的 I/O 接口呢？这是因为我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口，如此而已。基于字节的 I/O 操作接口读和写分别是：Reader 和 Writer。<br><img src=\"/2017/02/27/Java-IO/reader.png\" alt=\"Reader相关类层次结构\" title=\"Reader相关类层次结构\"></p>\n<img src=\"/2017/02/27/Java-IO/writer.png\" alt=\"Writer相关类层次结构\" title=\"Writer相关类层次结构\">\n<h3 id=\"2-3-基于磁盘操作的-I-O-接口\"><a href=\"#2-3-基于磁盘操作的-I-O-接口\" class=\"headerlink\" title=\"2.3 基于磁盘操作的 I/O 接口\"></a>2.3 基于磁盘操作的 I/O 接口</h3><p>前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。</p>\n<p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。<br>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>\n<p>下面以清单 1 的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：<br><img src=\"/2017/02/27/Java-IO/file.jpg\" alt=\"从磁盘读取文件\" title=\"从磁盘读取文件\"></p>\n<h3 id=\"2-4基于网络操作的-I-O-接口\"><a href=\"#2-4基于网络操作的-I-O-接口\" class=\"headerlink\" title=\"2.4基于网络操作的 I/O 接口\"></a>2.4基于网络操作的 I/O 接口</h3><p>Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。<br>下图是典型的基于 Socket 的通信的场景：</p>\n<img src=\"/2017/02/27/Java-IO/socket.jpg\" alt=\"Socket 通信示例\" title=\"Socket 通信示例\">\n<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>\n<h4 id=\"建立通信链路\"><a href=\"#建立通信链路\" class=\"headerlink\" title=\"建立通信链路\"></a>建立通信链路</h4><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。<br>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p>\n<h4 id=\"数据传输\"><a href=\"#数据传输\" class=\"headerlink\" title=\"数据传输\"></a>数据传输</h4><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。<br>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p>\n"},{"title":"TensorFlow","_content":"\n本篇讲一讲TensorFlow如何集成在Android上使用\n## TensorFlow在Android上的应用","source":"_posts/TensorFlow.md","raw":"---\ntitle: TensorFlow\ncategories: TensorFlow,Android\ntags: TensorFlow,Android\n---\n\n本篇讲一讲TensorFlow如何集成在Android上使用\n## TensorFlow在Android上的应用","slug":"TensorFlow","published":1,"date":"2017-02-26T09:21:31.052Z","updated":"2017-02-26T09:21:31.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqzwtvy00065h2dhd3pqq71","content":"<p>本篇讲一讲TensorFlow如何集成在Android上使用</p>\n<h2 id=\"TensorFlow在Android上的应用\"><a href=\"#TensorFlow在Android上的应用\" class=\"headerlink\" title=\"TensorFlow在Android上的应用\"></a>TensorFlow在Android上的应用</h2>","excerpt":"","more":"<p>本篇讲一讲TensorFlow如何集成在Android上使用</p>\n<h2 id=\"TensorFlow在Android上的应用\"><a href=\"#TensorFlow在Android上的应用\" class=\"headerlink\" title=\"TensorFlow在Android上的应用\"></a>TensorFlow在Android上的应用</h2>"},{"title":"记一次需求的开发--在ViewPager中嵌套WebView","_content":"\n###  前言\n ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。\n \n### Android事件传递机制\n其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。\n\n我们从事件开始传递的最初入口开始讲起\n### Activity\n事件是从Activity开始传递，具体代码如下：\n`Activity.java`\n```\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n    \t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n在看Window里的superDispatchTouchEvent是怎么实现的\n这里的getWindow返回的winow是PhoneWindow的实例\n`PhoneWindow.java`\n```\n    @Override\n    public boolean superDispatchKeyEvent(KeyEvent event) {\n    \t//这里调用的是mDecor的superDispatchKeyEvent\n        return mDecor.superDispatchKeyEvent(event);\n    }\n```\n\nmDecor是DecorView的实例\n`DecorView.java`\n```\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n       //这里是调用的父类的dispatchKeyShortcutEvent方法\n        return super.dispatchTouchEvent(event);\n    }\n```\nDecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。\nInfiniteData\n第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。\n\n## ViewGroup\n这里就进入到递归的主要逻辑里面，只要把这里搞懂，那其实就是搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析\n`dispatchTouchEvent`\n\n```\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n        }\n\n        // If the event targets the accessibility focused view and this is it, start\n        // normal event dispatch. Maybe a descendant is what will handle the click.\n        if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        boolean handled = false;\n        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码\n        if (onFilterTouchEventForSecurity(ev)) {\n        //获取当前事件的action\n            final int action = ev.getAction();\n            //获取当前事件是哪个action\n            final int actionMasked = action & MotionEvent.ACTION_MASK;\n\n            // Handle an initial down.\n            //如果事件为down事件\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递\n            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下\n                    //首先，(mGroupFlags & FLAG_DISALLOW_INTERCEPT) ，因为是&操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            // If intercepted, start normal event dispatch. Also if there is already\n            // a view that is handling the gesture, do normal event dispatch.\n            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发\n            if (intercepted || mFirstTouchTarget != null) {\n                ev.setTargetAccessibilityFocus(false);\n            }\n\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n\n            // Update list of touch targets for pointer down, if needed.\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n            //这里如果canceld和intercept都为false，才会分发事件\n            if (!canceled && !intercepted) {\n\n                // If the event is targeting accessiiblity focus we give it to the\n                // view that has accessibility focus and if it does not handle it\n                // we clear the flag and dispatch the event to all children as usual.\n                // We are looking up the accessibility focused host to avoid keeping\n                // state since these events are very rare.\n                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                        ? findChildWithAccessibilityFocus() : null;\n\n\t\t//这里actionMasked如果符合这些条件\n                if (actionMasked == MotionEvent.ACTION_DOWN\n                        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                    final int actionIndex = ev.getActionIndex(); // always 0 for down\n                    final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n                            : TouchTarget.ALL_POINTER_IDS;\n\n                    // Clean up earlier touch targets for this pointer id in case they\n                    // have become out of sync.\n                    removePointersFromTouchTargets(idBitsToAssign);\n\n\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量\n                    final int childrenCount = mChildrenCount;\n                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了\n                    if (newTouchTarget == null && childrenCount != 0) {\n                        final float x = ev.getX(actionIndex);\n                        final float y = ev.getY(actionIndex);\n                        // Find a child that can receive the event.\n                        // Scan children from front to back.\n                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序\n                        final ArrayList<View> preorderedList = buildOrderedChildList();\n                        final boolean customOrder = preorderedList == null\n                                && isChildrenDrawingOrderEnabled();\n                                //mChildren为全局变量，储存viewgroup的子view\n                        final View[] children = mChildren;\n                        //遍历子view\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = customOrder\n                                    ? getChildDrawingOrder(childrenCount, i) : i;\n                            final View child = (preorderedList == null)\n                                    ? children[childIndex] : preorderedList.get(childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            newTouchTarget = getTouchTarget(child);\n                            if (newTouchTarget != null) {\n                                // Child is already receiving touch within its bounds.\n                                // Give it the new pointer in addition to the ones it is handling.\n                                newTouchTarget.pointerIdBits |= idBitsToAssign;\n                                break;\n                            }\n\n                            resetCancelNextUpFlag(child);\n                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n\n                    if (newTouchTarget == null && mFirstTouchTarget != null) {\n                        // Did not find a child to receive the event.\n                        // Assign the pointer to the least recently added target.\n                        newTouchTarget = mFirstTouchTarget;\n                        while (newTouchTarget.next != null) {\n                            newTouchTarget = newTouchTarget.next;\n                        }\n                        newTouchTarget.pointerIdBits |= idBitsToAssign;\n                    }\n                }\n            }\n\n            // Dispatch to touch targets.\n            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                 //mFirstTouchTarget为null，代表没有可接受事件的子view\n                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n\n            // Update list of touch targets for pointer up or cancel, if needed.\n            if (canceled\n                    || actionMasked == MotionEvent.ACTION_UP\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                resetTouchState();\n            } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n                removePointersFromTouchTargets(idBitsToRemove);\n            }\n        }\n\n        if (!handled && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n        }\n        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，\n        return handled;\n    }\n```\n\n\n`onFilterTouchEventForSecurity`\n```\n根据这个方法的注释，很容易理解这个方法的含义\n/**\n     * Filter the touch event to apply security policies.\n     *\n     * @param event The motion event to be filtered.\n     * @return True if the event should be dispatched, false if the event should be dropped.\n     *\n     * @see #getFilterTouchesWhenObscured\n     */\n    public boolean onFilterTouchEventForSecurity(MotionEvent event) {\n        //noinspection RedundantIfStatement\n        if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0\n                && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {\n            // Window is obscured, drop this touch.\n            return false;\n        }\n        return true;\n    }\n```\n`requestDisallowInterceptTouchEvent`\n```\n/**\n     * {@inheritDoc}\n     */\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\n`dispatchTransformedTouchEvent`\n```\n/**\n     * Transforms a motion event into the coordinate space of a particular child view,\n     * filters out irrelevant pointer ids, and overrides its action if necessary.\n     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.\n     */\n    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n\n        // Canceling motions is a special case.  We don't need to perform any transformations\n        // or filtering.  The important part is the action, not the contents.\n        //看注释，就是这是处理特殊case的代码\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        // Calculate the number of pointers to deliver.\n        final int oldPointerIdBits = event.getPointerIdBits();\n        final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;\n\n        // If for some reason we ended up in an inconsistent state where it looks like we\n        // might produce a motion event with no pointers in it, then drop the event.\n        if (newPointerIdBits == 0) {\n            return false;\n        }\n\n        // If the number of pointers is the same and we don't need to perform any fancy\n        // irreversible transformations, then we can reuse the motion event for this\n        // dispatch as long as we are careful to revert any changes we make.\n        // Otherwise we need to make a copy.\n        final MotionEvent transformedEvent;\n        //这个才是重点\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\t\n\t//这里和上面同理\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n            final float offsetX = mScrollX - child.mLeft;\n            final float offsetY = mScrollY - child.mTop;\n            transformedEvent.offsetLocation(offsetX, offsetY);\n            if (! child.hasIdentityMatrix()) {\n                transformedEvent.transform(child.getInverseMatrix());\n            }\n\n            handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值\n        return handled;\n    }\n```\n\n### View","source":"_posts/viewpager-webview.md","raw":"---\ntitle: 记一次需求的开发--在ViewPager中嵌套WebView\ncategories: Android\ntags: Android\n---\n\n###  前言\n ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。\n \n### Android事件传递机制\n其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。\n\n我们从事件开始传递的最初入口开始讲起\n### Activity\n事件是从Activity开始传递，具体代码如下：\n`Activity.java`\n```\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n    \t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n在看Window里的superDispatchTouchEvent是怎么实现的\n这里的getWindow返回的winow是PhoneWindow的实例\n`PhoneWindow.java`\n```\n    @Override\n    public boolean superDispatchKeyEvent(KeyEvent event) {\n    \t//这里调用的是mDecor的superDispatchKeyEvent\n        return mDecor.superDispatchKeyEvent(event);\n    }\n```\n\nmDecor是DecorView的实例\n`DecorView.java`\n```\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n       //这里是调用的父类的dispatchKeyShortcutEvent方法\n        return super.dispatchTouchEvent(event);\n    }\n```\nDecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。\nInfiniteData\n第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。\n\n## ViewGroup\n这里就进入到递归的主要逻辑里面，只要把这里搞懂，那其实就是搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析\n`dispatchTouchEvent`\n\n```\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n        }\n\n        // If the event targets the accessibility focused view and this is it, start\n        // normal event dispatch. Maybe a descendant is what will handle the click.\n        if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        boolean handled = false;\n        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码\n        if (onFilterTouchEventForSecurity(ev)) {\n        //获取当前事件的action\n            final int action = ev.getAction();\n            //获取当前事件是哪个action\n            final int actionMasked = action & MotionEvent.ACTION_MASK;\n\n            // Handle an initial down.\n            //如果事件为down事件\n            if (actionMasked == MotionEvent.ACTION_DOWN) {\n                // Throw away all previous state when starting a new touch gesture.\n                // The framework may have dropped the up or cancel event for the previous gesture\n                // due to an app switch, ANR, or some other state change.\n                cancelAndClearTouchTargets(ev);\n                resetTouchState();\n            }\n\n            // Check for interception.\n            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递\n            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去\n            final boolean intercepted;\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || mFirstTouchTarget != null) {\n                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下\n                    //首先，(mGroupFlags & FLAG_DISALLOW_INTERCEPT) ，因为是&操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发\n                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n                if (!disallowIntercept) {\n                    intercepted = onInterceptTouchEvent(ev);\n                    ev.setAction(action); // restore action in case it was changed\n                } else {\n                    intercepted = false;\n                }\n            } else {\n                // There are no touch targets and this action is not an initial down\n                // so this view group continues to intercept touches.\n                intercepted = true;\n            }\n\n            // If intercepted, start normal event dispatch. Also if there is already\n            // a view that is handling the gesture, do normal event dispatch.\n            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发\n            if (intercepted || mFirstTouchTarget != null) {\n                ev.setTargetAccessibilityFocus(false);\n            }\n\n            // Check for cancelation.\n            final boolean canceled = resetCancelNextUpFlag(this)\n                    || actionMasked == MotionEvent.ACTION_CANCEL;\n\n            // Update list of touch targets for pointer down, if needed.\n            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n            TouchTarget newTouchTarget = null;\n            boolean alreadyDispatchedToNewTouchTarget = false;\n            //这里如果canceld和intercept都为false，才会分发事件\n            if (!canceled && !intercepted) {\n\n                // If the event is targeting accessiiblity focus we give it to the\n                // view that has accessibility focus and if it does not handle it\n                // we clear the flag and dispatch the event to all children as usual.\n                // We are looking up the accessibility focused host to avoid keeping\n                // state since these events are very rare.\n                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                        ? findChildWithAccessibilityFocus() : null;\n\n\t\t//这里actionMasked如果符合这些条件\n                if (actionMasked == MotionEvent.ACTION_DOWN\n                        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                    final int actionIndex = ev.getActionIndex(); // always 0 for down\n                    final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n                            : TouchTarget.ALL_POINTER_IDS;\n\n                    // Clean up earlier touch targets for this pointer id in case they\n                    // have become out of sync.\n                    removePointersFromTouchTargets(idBitsToAssign);\n\n\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量\n                    final int childrenCount = mChildrenCount;\n                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了\n                    if (newTouchTarget == null && childrenCount != 0) {\n                        final float x = ev.getX(actionIndex);\n                        final float y = ev.getY(actionIndex);\n                        // Find a child that can receive the event.\n                        // Scan children from front to back.\n                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序\n                        final ArrayList<View> preorderedList = buildOrderedChildList();\n                        final boolean customOrder = preorderedList == null\n                                && isChildrenDrawingOrderEnabled();\n                                //mChildren为全局变量，储存viewgroup的子view\n                        final View[] children = mChildren;\n                        //遍历子view\n                        for (int i = childrenCount - 1; i >= 0; i--) {\n                            final int childIndex = customOrder\n                                    ? getChildDrawingOrder(childrenCount, i) : i;\n                            final View child = (preorderedList == null)\n                                    ? children[childIndex] : preorderedList.get(childIndex);\n\n                            // If there is a view that has accessibility focus we want it\n                            // to get the event first and if not handled we will perform a\n                            // normal dispatch. We may do a double iteration but this is\n                            // safer given the timeframe.\n                            if (childWithAccessibilityFocus != null) {\n                                if (childWithAccessibilityFocus != child) {\n                                    continue;\n                                }\n                                childWithAccessibilityFocus = null;\n                                i = childrenCount - 1;\n                            }\n\n                            if (!canViewReceivePointerEvents(child)\n                                    || !isTransformedTouchPointInView(x, y, child, null)) {\n                                ev.setTargetAccessibilityFocus(false);\n                                continue;\n                            }\n\n                            newTouchTarget = getTouchTarget(child);\n                            if (newTouchTarget != null) {\n                                // Child is already receiving touch within its bounds.\n                                // Give it the new pointer in addition to the ones it is handling.\n                                newTouchTarget.pointerIdBits |= idBitsToAssign;\n                                break;\n                            }\n\n                            resetCancelNextUpFlag(child);\n                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发\n                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                                // Child wants to receive touch within its bounds.\n                                mLastTouchDownTime = ev.getDownTime();\n                                if (preorderedList != null) {\n                                    // childIndex points into presorted list, find original index\n                                    for (int j = 0; j < childrenCount; j++) {\n                                        if (children[childIndex] == mChildren[j]) {\n                                            mLastTouchDownIndex = j;\n                                            break;\n                                        }\n                                    }\n                                } else {\n                                    mLastTouchDownIndex = childIndex;\n                                }\n                                mLastTouchDownX = ev.getX();\n                                mLastTouchDownY = ev.getY();\n                                newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                                alreadyDispatchedToNewTouchTarget = true;\n                                break;\n                            }\n\n                            // The accessibility focus didn't handle the event, so clear\n                            // the flag and do a normal dispatch to all children.\n                            ev.setTargetAccessibilityFocus(false);\n                        }\n                        if (preorderedList != null) preorderedList.clear();\n                    }\n\n                    if (newTouchTarget == null && mFirstTouchTarget != null) {\n                        // Did not find a child to receive the event.\n                        // Assign the pointer to the least recently added target.\n                        newTouchTarget = mFirstTouchTarget;\n                        while (newTouchTarget.next != null) {\n                            newTouchTarget = newTouchTarget.next;\n                        }\n                        newTouchTarget.pointerIdBits |= idBitsToAssign;\n                    }\n                }\n            }\n\n            // Dispatch to touch targets.\n            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存\n            if (mFirstTouchTarget == null) {\n                // No touch targets so treat this as an ordinary view.\n                 //mFirstTouchTarget为null，代表没有可接受事件的子view\n                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件\n                handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                        TouchTarget.ALL_POINTER_IDS);\n            } else {\n                // Dispatch to touch targets, excluding the new touch target if we already\n                // dispatched to it.  Cancel touch targets if necessary.\n                TouchTarget predecessor = null;\n                TouchTarget target = mFirstTouchTarget;\n                while (target != null) {\n                    final TouchTarget next = target.next;\n                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n                        handled = true;\n                    } else {\n                        final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                                || intercepted;\n                        if (dispatchTransformedTouchEvent(ev, cancelChild,\n                                target.child, target.pointerIdBits)) {\n                            handled = true;\n                        }\n                        if (cancelChild) {\n                            if (predecessor == null) {\n                                mFirstTouchTarget = next;\n                            } else {\n                                predecessor.next = next;\n                            }\n                            target.recycle();\n                            target = next;\n                            continue;\n                        }\n                    }\n                    predecessor = target;\n                    target = next;\n                }\n            }\n\n            // Update list of touch targets for pointer up or cancel, if needed.\n            if (canceled\n                    || actionMasked == MotionEvent.ACTION_UP\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                resetTouchState();\n            } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n                removePointersFromTouchTargets(idBitsToRemove);\n            }\n        }\n\n        if (!handled && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n        }\n        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，\n        return handled;\n    }\n```\n\n\n`onFilterTouchEventForSecurity`\n```\n根据这个方法的注释，很容易理解这个方法的含义\n/**\n     * Filter the touch event to apply security policies.\n     *\n     * @param event The motion event to be filtered.\n     * @return True if the event should be dispatched, false if the event should be dropped.\n     *\n     * @see #getFilterTouchesWhenObscured\n     */\n    public boolean onFilterTouchEventForSecurity(MotionEvent event) {\n        //noinspection RedundantIfStatement\n        if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0\n                && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {\n            // Window is obscured, drop this touch.\n            return false;\n        }\n        return true;\n    }\n```\n`requestDisallowInterceptTouchEvent`\n```\n/**\n     * {@inheritDoc}\n     */\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\n`dispatchTransformedTouchEvent`\n```\n/**\n     * Transforms a motion event into the coordinate space of a particular child view,\n     * filters out irrelevant pointer ids, and overrides its action if necessary.\n     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.\n     */\n    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n        final boolean handled;\n\n        // Canceling motions is a special case.  We don't need to perform any transformations\n        // or filtering.  The important part is the action, not the contents.\n        //看注释，就是这是处理特殊case的代码\n        final int oldAction = event.getAction();\n        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n            event.setAction(MotionEvent.ACTION_CANCEL);\n            if (child == null) {\n                handled = super.dispatchTouchEvent(event);\n            } else {\n                handled = child.dispatchTouchEvent(event);\n            }\n            event.setAction(oldAction);\n            return handled;\n        }\n\n        // Calculate the number of pointers to deliver.\n        final int oldPointerIdBits = event.getPointerIdBits();\n        final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;\n\n        // If for some reason we ended up in an inconsistent state where it looks like we\n        // might produce a motion event with no pointers in it, then drop the event.\n        if (newPointerIdBits == 0) {\n            return false;\n        }\n\n        // If the number of pointers is the same and we don't need to perform any fancy\n        // irreversible transformations, then we can reuse the motion event for this\n        // dispatch as long as we are careful to revert any changes we make.\n        // Otherwise we need to make a copy.\n        final MotionEvent transformedEvent;\n        //这个才是重点\n        if (newPointerIdBits == oldPointerIdBits) {\n            if (child == null || child.hasIdentityMatrix()) {\n                if (child == null) {\n                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件\n                    handled = super.dispatchTouchEvent(event);\n                } else {\n                    final float offsetX = mScrollX - child.mLeft;\n                    final float offsetY = mScrollY - child.mTop;\n                    event.offsetLocation(offsetX, offsetY);\n\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view\n                    handled = child.dispatchTouchEvent(event);\n\n                    event.offsetLocation(-offsetX, -offsetY);\n                }\n                return handled;\n            }\n            transformedEvent = MotionEvent.obtain(event);\n        } else {\n            transformedEvent = event.split(newPointerIdBits);\n        }\n\t\n\t//这里和上面同理\n        // Perform any necessary transformations and dispatch.\n        if (child == null) {\n            handled = super.dispatchTouchEvent(transformedEvent);\n        } else {\n            final float offsetX = mScrollX - child.mLeft;\n            final float offsetY = mScrollY - child.mTop;\n            transformedEvent.offsetLocation(offsetX, offsetY);\n            if (! child.hasIdentityMatrix()) {\n                transformedEvent.transform(child.getInverseMatrix());\n            }\n\n            handled = child.dispatchTouchEvent(transformedEvent);\n        }\n\n        // Done.\n        transformedEvent.recycle();\n        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值\n        return handled;\n    }\n```\n\n### View","slug":"viewpager-webview","published":1,"date":"2017-03-10T14:01:41.246Z","updated":"2017-03-10T14:01:41.246Z","_id":"cizqzwtw100085h2dxelhm3rk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p> ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。</p>\n<h3 id=\"Android事件传递机制\"><a href=\"#Android事件传递机制\" class=\"headerlink\" title=\"Android事件传递机制\"></a>Android事件传递机制</h3><p>其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。</p>\n<p>我们从事件开始传递的最初入口开始讲起</p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>事件是从Activity开始传递，具体代码如下：<br><code>Activity.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空</div><div class=\"line\">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件</div><div class=\"line\">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在看Window里的superDispatchTouchEvent是怎么实现的<br>这里的getWindow返回的winow是PhoneWindow的实例<br><code>PhoneWindow.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean superDispatchKeyEvent(KeyEvent event) &#123;</div><div class=\"line\">\t//这里调用的是mDecor的superDispatchKeyEvent</div><div class=\"line\">    return mDecor.superDispatchKeyEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>mDecor是DecorView的实例<br><code>DecorView.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       //这里是调用的父类的dispatchKeyShortcutEvent方法</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>DecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。<br>InfiniteData<br>第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。</p>\n<h2 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h2><p>这里就进入到递归的主要逻辑里面，只要把这里搞懂，那其实就是搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的</div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the event targets the accessibility focused view and this is it, start</div><div class=\"line\">        // normal event dispatch. Maybe a descendant is what will handle the click.</div><div class=\"line\">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean handled = false;</div><div class=\"line\">        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码</div><div class=\"line\">        if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class=\"line\">        //获取当前事件的action</div><div class=\"line\">            final int action = ev.getAction();</div><div class=\"line\">            //获取当前事件是哪个action</div><div class=\"line\">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class=\"line\"></div><div class=\"line\">            // Handle an initial down.</div><div class=\"line\">            //如果事件为down事件</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">                // Throw away all previous state when starting a new touch gesture.</div><div class=\"line\">                // The framework may have dropped the up or cancel event for the previous gesture</div><div class=\"line\">                // due to an app switch, ANR, or some other state change.</div><div class=\"line\">                cancelAndClearTouchTargets(ev);</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for interception.</div><div class=\"line\">            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递</div><div class=\"line\">            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去</div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下</div><div class=\"line\">                    //首先，(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) ，因为是&amp;操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If intercepted, start normal event dispatch. Also if there is already</div><div class=\"line\">            // a view that is handling the gesture, do normal event dispatch.</div><div class=\"line\">            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发</div><div class=\"line\">            if (intercepted || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for cancelation.</div><div class=\"line\">            final boolean canceled = resetCancelNextUpFlag(this)</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer down, if needed.</div><div class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class=\"line\">            TouchTarget newTouchTarget = null;</div><div class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</div><div class=\"line\">            //这里如果canceld和intercept都为false，才会分发事件</div><div class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</div><div class=\"line\"></div><div class=\"line\">                // If the event is targeting accessiiblity focus we give it to the</div><div class=\"line\">                // view that has accessibility focus and if it does not handle it</div><div class=\"line\">                // we clear the flag and dispatch the event to all children as usual.</div><div class=\"line\">                // We are looking up the accessibility focused host to avoid keeping</div><div class=\"line\">                // state since these events are very rare.</div><div class=\"line\">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class=\"line\">                        ? findChildWithAccessibilityFocus() : null;</div><div class=\"line\"></div><div class=\"line\">\t\t//这里actionMasked如果符合这些条件</div><div class=\"line\">                if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class=\"line\">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class=\"line\">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class=\"line\">                            : TouchTarget.ALL_POINTER_IDS;</div><div class=\"line\"></div><div class=\"line\">                    // Clean up earlier touch targets for this pointer id in case they</div><div class=\"line\">                    // have become out of sync.</div><div class=\"line\">                    removePointersFromTouchTargets(idBitsToAssign);</div><div class=\"line\"></div><div class=\"line\">\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量</div><div class=\"line\">                    final int childrenCount = mChildrenCount;</div><div class=\"line\">                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了</div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class=\"line\">                        final float x = ev.getX(actionIndex);</div><div class=\"line\">                        final float y = ev.getY(actionIndex);</div><div class=\"line\">                        // Find a child that can receive the event.</div><div class=\"line\">                        // Scan children from front to back.</div><div class=\"line\">                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序</div><div class=\"line\">                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class=\"line\">                        final boolean customOrder = preorderedList == null</div><div class=\"line\">                                &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class=\"line\">                                //mChildren为全局变量，储存viewgroup的子view</div><div class=\"line\">                        final View[] children = mChildren;</div><div class=\"line\">                        //遍历子view</div><div class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">                            final int childIndex = customOrder</div><div class=\"line\">                                    ? getChildDrawingOrder(childrenCount, i) : i;</div><div class=\"line\">                            final View child = (preorderedList == null)</div><div class=\"line\">                                    ? children[childIndex] : preorderedList.get(childIndex);</div><div class=\"line\"></div><div class=\"line\">                            // If there is a view that has accessibility focus we want it</div><div class=\"line\">                            // to get the event first and if not handled we will perform a</div><div class=\"line\">                            // normal dispatch. We may do a double iteration but this is</div><div class=\"line\">                            // safer given the timeframe.</div><div class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</div><div class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</div><div class=\"line\">                                    continue;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                childWithAccessibilityFocus = null;</div><div class=\"line\">                                i = childrenCount - 1;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            if (!canViewReceivePointerEvents(child)</div><div class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class=\"line\">                                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                                continue;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            newTouchTarget = getTouchTarget(child);</div><div class=\"line\">                            if (newTouchTarget != null) &#123;</div><div class=\"line\">                                // Child is already receiving touch within its bounds.</div><div class=\"line\">                                // Give it the new pointer in addition to the ones it is handling.</div><div class=\"line\">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            resetCancelNextUpFlag(child);</div><div class=\"line\">                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发</div><div class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class=\"line\">                                // Child wants to receive touch within its bounds.</div><div class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</div><div class=\"line\">                                if (preorderedList != null) &#123;</div><div class=\"line\">                                    // childIndex points into presorted list, find original index</div><div class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class=\"line\">                                            mLastTouchDownIndex = j;</div><div class=\"line\">                                            break;</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125; else &#123;</div><div class=\"line\">                                    mLastTouchDownIndex = childIndex;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                mLastTouchDownX = ev.getX();</div><div class=\"line\">                                mLastTouchDownY = ev.getY();</div><div class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</div><div class=\"line\">                            // the flag and do a normal dispatch to all children.</div><div class=\"line\">                            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (preorderedList != null) preorderedList.clear();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class=\"line\">                        // Did not find a child to receive the event.</div><div class=\"line\">                        // Assign the pointer to the least recently added target.</div><div class=\"line\">                        newTouchTarget = mFirstTouchTarget;</div><div class=\"line\">                        while (newTouchTarget.next != null) &#123;</div><div class=\"line\">                            newTouchTarget = newTouchTarget.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dispatch to touch targets.</div><div class=\"line\">            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存</div><div class=\"line\">            if (mFirstTouchTarget == null) &#123;</div><div class=\"line\">                // No touch targets so treat this as an ordinary view.</div><div class=\"line\">                 //mFirstTouchTarget为null，代表没有可接受事件的子view</div><div class=\"line\">                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件</div><div class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</div><div class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</div><div class=\"line\">                TouchTarget predecessor = null;</div><div class=\"line\">                TouchTarget target = mFirstTouchTarget;</div><div class=\"line\">                while (target != null) &#123;</div><div class=\"line\">                    final TouchTarget next = target.next;</div><div class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class=\"line\">                        handled = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class=\"line\">                                || intercepted;</div><div class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class=\"line\">                                target.child, target.pointerIdBits)) &#123;</div><div class=\"line\">                            handled = true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (cancelChild) &#123;</div><div class=\"line\">                            if (predecessor == null) &#123;</div><div class=\"line\">                                mFirstTouchTarget = next;</div><div class=\"line\">                            &#125; else &#123;</div><div class=\"line\">                                predecessor.next = next;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            target.recycle();</div><div class=\"line\">                            target = next;</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    predecessor = target;</div><div class=\"line\">                    target = next;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer up or cancel, if needed.</div><div class=\"line\">            if (canceled</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_UP</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class=\"line\">                final int actionIndex = ev.getActionIndex();</div><div class=\"line\">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class=\"line\">                removePointersFromTouchTargets(idBitsToRemove);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onFilterTouchEventForSecurity</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据这个方法的注释，很容易理解这个方法的含义</div><div class=\"line\">/**</div><div class=\"line\">     * Filter the touch event to apply security policies.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be filtered.</div><div class=\"line\">     * @return True if the event should be dispatched, false if the event should be dropped.</div><div class=\"line\">     *</div><div class=\"line\">     * @see #getFilterTouchesWhenObscured</div><div class=\"line\">     */</div><div class=\"line\">    public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</div><div class=\"line\">        //noinspection RedundantIfStatement</div><div class=\"line\">        if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</div><div class=\"line\">                &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</div><div class=\"line\">            // Window is obscured, drop this touch.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>requestDisallowInterceptTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * &#123;@inheritDoc&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</div><div class=\"line\">            // We&apos;re already in this state, assume our ancestors are too</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept) &#123;</div><div class=\"line\">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Pass it up to our parent</div><div class=\"line\">        if (mParent != null) &#123;</div><div class=\"line\">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>dispatchTransformedTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Transforms a motion event into the coordinate space of a particular child view,</div><div class=\"line\">     * filters out irrelevant pointer ids, and overrides its action if necessary.</div><div class=\"line\">     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</div><div class=\"line\">     */</div><div class=\"line\">    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class=\"line\">            View child, int desiredPointerIdBits) &#123;</div><div class=\"line\">        final boolean handled;</div><div class=\"line\"></div><div class=\"line\">        // Canceling motions is a special case.  We don&apos;t need to perform any transformations</div><div class=\"line\">        // or filtering.  The important part is the action, not the contents.</div><div class=\"line\">        //看注释，就是这是处理特殊case的代码</div><div class=\"line\">        final int oldAction = event.getAction();</div><div class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</div><div class=\"line\">            if (child == null) &#123;</div><div class=\"line\">                handled = super.dispatchTouchEvent(event);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handled = child.dispatchTouchEvent(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            event.setAction(oldAction);</div><div class=\"line\">            return handled;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Calculate the number of pointers to deliver.</div><div class=\"line\">        final int oldPointerIdBits = event.getPointerIdBits();</div><div class=\"line\">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class=\"line\"></div><div class=\"line\">        // If for some reason we ended up in an inconsistent state where it looks like we</div><div class=\"line\">        // might produce a motion event with no pointers in it, then drop the event.</div><div class=\"line\">        if (newPointerIdBits == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the number of pointers is the same and we don&apos;t need to perform any fancy</div><div class=\"line\">        // irreversible transformations, then we can reuse the motion event for this</div><div class=\"line\">        // dispatch as long as we are careful to revert any changes we make.</div><div class=\"line\">        // Otherwise we need to make a copy.</div><div class=\"line\">        final MotionEvent transformedEvent;</div><div class=\"line\">        //这个才是重点</div><div class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                if (child == null) &#123;</div><div class=\"line\">                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件</div><div class=\"line\">                    handled = super.dispatchTouchEvent(event);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">                    final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">                    event.offsetLocation(offsetX, offsetY);</div><div class=\"line\">\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view</div><div class=\"line\">                    handled = child.dispatchTouchEvent(event);</div><div class=\"line\"></div><div class=\"line\">                    event.offsetLocation(-offsetX, -offsetY);</div><div class=\"line\">                &#125;</div><div class=\"line\">                return handled;</div><div class=\"line\">            &#125;</div><div class=\"line\">            transformedEvent = MotionEvent.obtain(event);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            transformedEvent = event.split(newPointerIdBits);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//这里和上面同理</div><div class=\"line\">        // Perform any necessary transformations and dispatch.</div><div class=\"line\">        if (child == null) &#123;</div><div class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">            final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">            transformedEvent.offsetLocation(offsetX, offsetY);</div><div class=\"line\">            if (! child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                transformedEvent.transform(child.getInverseMatrix());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handled = child.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Done.</div><div class=\"line\">        transformedEvent.recycle();</div><div class=\"line\">        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3>","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p> ViewPager是可以左右滑动的组件，我们经常会用到，当ViewPager中嵌套了WebView且WebView中的内容也需要左右滑动的时候就会出现事件冲突：因为ViewPager需要消费左右滑动的事件，WebView也需要消费左右滑动的事件，那么该如何解决这样的问题？首先我们来回顾下Android事件传递的机制。</p>\n<h3 id=\"Android事件传递机制\"><a href=\"#Android事件传递机制\" class=\"headerlink\" title=\"Android事件传递机制\"></a>Android事件传递机制</h3><p>其实网上有很多讲解Android事件传递机制的文章，但感觉讲的都不是很清楚，因为网上大部分都是切割成三部分来讲，分别为：Activity、ViewGroup、View，但其实Android事件传递本质上是一个递归，如果单纯的切割开来，会忽略很多的内部实现细节，所以都不如自己看源代码来的实在。</p>\n<p>我们从事件开始传递的最初入口开始讲起</p>\n<h3 id=\"Activity\"><a href=\"#Activity\" class=\"headerlink\" title=\"Activity\"></a>Activity</h3><p>事件是从Activity开始传递，具体代码如下：<br><code>Activity.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//如果事件为ACTION_DOWN，则调用onUserInteraction(),我们可以看到这个函数的实现为空</div><div class=\"line\">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    //调用window的dispatchTouchEvent，如果返回true，即下层的消费了此事件，则直接return true，否则返回false，即下层没有消费此事件，就掉用Activity的onTouchEvent消费本次事件</div><div class=\"line\">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在看Window里的superDispatchTouchEvent是怎么实现的<br>这里的getWindow返回的winow是PhoneWindow的实例<br><code>PhoneWindow.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public boolean superDispatchKeyEvent(KeyEvent event) &#123;</div><div class=\"line\">\t//这里调用的是mDecor的superDispatchKeyEvent</div><div class=\"line\">    return mDecor.superDispatchKeyEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>mDecor是DecorView的实例<br><code>DecorView.java</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class=\"line\">       //这里是调用的父类的dispatchKeyShortcutEvent方法</div><div class=\"line\">        return super.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>DecoreView的父类是FrameLayout,FrameLayout没有实现dispatchTouchEvent，因此调用的是FrameLayout的父类ViewGroup的dispatchTouchEvent的方法。<br>InfiniteData<br>第一部分讲到这就结束了，因为我们都知道Activity的最外层包裹的是DecorView，DecoreView里面在包裹我们自己定义实现的Activity的view，而DecoreView继承自FrameLayout，本质上也是一个view，所以总结来说就是Activity获得了事件，随即就抛给了view来处理。</p>\n<h2 id=\"ViewGroup\"><a href=\"#ViewGroup\" class=\"headerlink\" title=\"ViewGroup\"></a>ViewGroup</h2><p>这里就进入到递归的主要逻辑里面，只要把这里搞懂，那其实就是搞懂了事件的传递机制，同样从代码入手，从上面第一节我们知道Activity里面的事件最后调用的是ViewGroup的dispatchTouchEvent事件，所以我们从ViewGroup 的dispatchTouchEvent看起，这里代码很多，我们一行一行来分析<br><code>dispatchTouchEvent</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class=\"line\">\t//此处mInputEventConsistencyVerifier是用于测试用的，很容易被迷惑，因为这也有onTouchEvent方法，会误以为在这里就消费了事件，其实没有，只是测试用的</div><div class=\"line\">        if (mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the event targets the accessibility focused view and this is it, start</div><div class=\"line\">        // normal event dispatch. Maybe a descendant is what will handle the click.</div><div class=\"line\">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</div><div class=\"line\">            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        boolean handled = false;</div><div class=\"line\">        //这里有一个方法 onFilterTouchEventForSecurity，是用来做安全校验的，通过校验true，则开始分发事件，否则将直接返回，看下面的具体代码</div><div class=\"line\">        if (onFilterTouchEventForSecurity(ev)) &#123;</div><div class=\"line\">        //获取当前事件的action</div><div class=\"line\">            final int action = ev.getAction();</div><div class=\"line\">            //获取当前事件是哪个action</div><div class=\"line\">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class=\"line\"></div><div class=\"line\">            // Handle an initial down.</div><div class=\"line\">            //如果事件为down事件</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">                // Throw away all previous state when starting a new touch gesture.</div><div class=\"line\">                // The framework may have dropped the up or cancel event for the previous gesture</div><div class=\"line\">                // due to an app switch, ANR, or some other state change.</div><div class=\"line\">                cancelAndClearTouchTargets(ev);</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for interception.</div><div class=\"line\">            //intercept这个是用来标记是否拦截此次事件的，true：拦截，自己消费，false：不拦截，接着往下传递</div><div class=\"line\">            //mFirstTouchTarget:是一个链表，用来保存这个viewgroup下面可以接受事件的view，这里如果为null，则代表这个viewgroup没有子view，所以不用分发事件，直接自己消费，这里是为了提高运行效率的。当然你第一次进来的时候，这个肯定为null，但是却满足了第一个条件，即事件为down事件，所以会走下去</div><div class=\"line\">            final boolean intercepted;</div><div class=\"line\">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                    || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                    //这里有一个flag，是通过requestDisallowInterceptTouchEvent来设置的，如果不拦截，则分发事件，否则自己处理，这里有点绕，详细解释下</div><div class=\"line\">                    //首先，(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) ，因为是&amp;操作，如果结果不等于0,则disallowIntercept为true，代表有FLAG_DISALLOW_INTERCEPT这个设置，这个viewgroup不执行onInterceptTouchEvent方法，对事件进行分发</div><div class=\"line\">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class=\"line\">                if (!disallowIntercept) &#123;</div><div class=\"line\">                    intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">                    ev.setAction(action); // restore action in case it was changed</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    intercepted = false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // There are no touch targets and this action is not an initial down</div><div class=\"line\">                // so this view group continues to intercept touches.</div><div class=\"line\">                intercepted = true;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // If intercepted, start normal event dispatch. Also if there is already</div><div class=\"line\">            // a view that is handling the gesture, do normal event dispatch.</div><div class=\"line\">            //这里intercepted如果为true，表示事件已经被viewgroup拦截，viewgroup会自己消费事件，如果为false，表示viewgroup暂时不消费此事件，需要对事件进行分发</div><div class=\"line\">            if (intercepted || mFirstTouchTarget != null) &#123;</div><div class=\"line\">                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Check for cancelation.</div><div class=\"line\">            final boolean canceled = resetCancelNextUpFlag(this)</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer down, if needed.</div><div class=\"line\">            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class=\"line\">            TouchTarget newTouchTarget = null;</div><div class=\"line\">            boolean alreadyDispatchedToNewTouchTarget = false;</div><div class=\"line\">            //这里如果canceld和intercept都为false，才会分发事件</div><div class=\"line\">            if (!canceled &amp;&amp; !intercepted) &#123;</div><div class=\"line\"></div><div class=\"line\">                // If the event is targeting accessiiblity focus we give it to the</div><div class=\"line\">                // view that has accessibility focus and if it does not handle it</div><div class=\"line\">                // we clear the flag and dispatch the event to all children as usual.</div><div class=\"line\">                // We are looking up the accessibility focused host to avoid keeping</div><div class=\"line\">                // state since these events are very rare.</div><div class=\"line\">                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class=\"line\">                        ? findChildWithAccessibilityFocus() : null;</div><div class=\"line\"></div><div class=\"line\">\t\t//这里actionMasked如果符合这些条件</div><div class=\"line\">                if (actionMasked == MotionEvent.ACTION_DOWN</div><div class=\"line\">                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class=\"line\">                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                    final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class=\"line\">                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class=\"line\">                            : TouchTarget.ALL_POINTER_IDS;</div><div class=\"line\"></div><div class=\"line\">                    // Clean up earlier touch targets for this pointer id in case they</div><div class=\"line\">                    // have become out of sync.</div><div class=\"line\">                    removePointersFromTouchTargets(idBitsToAssign);</div><div class=\"line\"></div><div class=\"line\">\t\t\t//mChildrenCount是全局变量，会记录viewgroup里子view的数量</div><div class=\"line\">                    final int childrenCount = mChildrenCount;</div><div class=\"line\">                    //从前面看到newTouchTarget为前面几行定义的局部变量，且初始值为null，所以这里只要childrenCount不为0,一定会走下面的逻辑，如果childrenCount为0,则viewgroup子view为0,也就不需要分发事件了</div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class=\"line\">                        final float x = ev.getX(actionIndex);</div><div class=\"line\">                        final float y = ev.getY(actionIndex);</div><div class=\"line\">                        // Find a child that can receive the event.</div><div class=\"line\">                        // Scan children from front to back.</div><div class=\"line\">                        //buildOrderedChildList这个方法会把viewgroup的所有子view按照前后顺序排序，以便决定接收事件的顺序</div><div class=\"line\">                        final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class=\"line\">                        final boolean customOrder = preorderedList == null</div><div class=\"line\">                                &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class=\"line\">                                //mChildren为全局变量，储存viewgroup的子view</div><div class=\"line\">                        final View[] children = mChildren;</div><div class=\"line\">                        //遍历子view</div><div class=\"line\">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">                            final int childIndex = customOrder</div><div class=\"line\">                                    ? getChildDrawingOrder(childrenCount, i) : i;</div><div class=\"line\">                            final View child = (preorderedList == null)</div><div class=\"line\">                                    ? children[childIndex] : preorderedList.get(childIndex);</div><div class=\"line\"></div><div class=\"line\">                            // If there is a view that has accessibility focus we want it</div><div class=\"line\">                            // to get the event first and if not handled we will perform a</div><div class=\"line\">                            // normal dispatch. We may do a double iteration but this is</div><div class=\"line\">                            // safer given the timeframe.</div><div class=\"line\">                            if (childWithAccessibilityFocus != null) &#123;</div><div class=\"line\">                                if (childWithAccessibilityFocus != child) &#123;</div><div class=\"line\">                                    continue;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                childWithAccessibilityFocus = null;</div><div class=\"line\">                                i = childrenCount - 1;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            if (!canViewReceivePointerEvents(child)</div><div class=\"line\">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class=\"line\">                                ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                                continue;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            newTouchTarget = getTouchTarget(child);</div><div class=\"line\">                            if (newTouchTarget != null) &#123;</div><div class=\"line\">                                // Child is already receiving touch within its bounds.</div><div class=\"line\">                                // Give it the new pointer in addition to the ones it is handling.</div><div class=\"line\">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            resetCancelNextUpFlag(child);</div><div class=\"line\">                            //dispatchTransformedTouchEvent就是分发事件的函数，我们可以往下看它具体的代码，这里如果返回true，则代表有子view消费了此次事件，那么分发到此为止，如果为false，则继续分发</div><div class=\"line\">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class=\"line\">                                // Child wants to receive touch within its bounds.</div><div class=\"line\">                                mLastTouchDownTime = ev.getDownTime();</div><div class=\"line\">                                if (preorderedList != null) &#123;</div><div class=\"line\">                                    // childIndex points into presorted list, find original index</div><div class=\"line\">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class=\"line\">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class=\"line\">                                            mLastTouchDownIndex = j;</div><div class=\"line\">                                            break;</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;</div><div class=\"line\">                                &#125; else &#123;</div><div class=\"line\">                                    mLastTouchDownIndex = childIndex;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                mLastTouchDownX = ev.getX();</div><div class=\"line\">                                mLastTouchDownY = ev.getY();</div><div class=\"line\">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class=\"line\">                                alreadyDispatchedToNewTouchTarget = true;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\"></div><div class=\"line\">                            // The accessibility focus didn&apos;t handle the event, so clear</div><div class=\"line\">                            // the flag and do a normal dispatch to all children.</div><div class=\"line\">                            ev.setTargetAccessibilityFocus(false);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (preorderedList != null) preorderedList.clear();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class=\"line\">                        // Did not find a child to receive the event.</div><div class=\"line\">                        // Assign the pointer to the least recently added target.</div><div class=\"line\">                        newTouchTarget = mFirstTouchTarget;</div><div class=\"line\">                        while (newTouchTarget.next != null) &#123;</div><div class=\"line\">                            newTouchTarget = newTouchTarget.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dispatch to touch targets.</div><div class=\"line\">            //mFirstTouchTarget是viewgroup可接受事件的子view的缓存</div><div class=\"line\">            if (mFirstTouchTarget == null) &#123;</div><div class=\"line\">                // No touch targets so treat this as an ordinary view.</div><div class=\"line\">                 //mFirstTouchTarget为null，代表没有可接受事件的子view</div><div class=\"line\">                //所以dispatchTransformedTouchEvent中child的变量为null，意思是自己来消费事件</div><div class=\"line\">                handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class=\"line\">                        TouchTarget.ALL_POINTER_IDS);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Dispatch to touch targets, excluding the new touch target if we already</div><div class=\"line\">                // dispatched to it.  Cancel touch targets if necessary.</div><div class=\"line\">                TouchTarget predecessor = null;</div><div class=\"line\">                TouchTarget target = mFirstTouchTarget;</div><div class=\"line\">                while (target != null) &#123;</div><div class=\"line\">                    final TouchTarget next = target.next;</div><div class=\"line\">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</div><div class=\"line\">                        handled = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class=\"line\">                                || intercepted;</div><div class=\"line\">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class=\"line\">                                target.child, target.pointerIdBits)) &#123;</div><div class=\"line\">                            handled = true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (cancelChild) &#123;</div><div class=\"line\">                            if (predecessor == null) &#123;</div><div class=\"line\">                                mFirstTouchTarget = next;</div><div class=\"line\">                            &#125; else &#123;</div><div class=\"line\">                                predecessor.next = next;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            target.recycle();</div><div class=\"line\">                            target = next;</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    predecessor = target;</div><div class=\"line\">                    target = next;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Update list of touch targets for pointer up or cancel, if needed.</div><div class=\"line\">            if (canceled</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_UP</div><div class=\"line\">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">                resetTouchState();</div><div class=\"line\">            &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class=\"line\">                final int actionIndex = ev.getActionIndex();</div><div class=\"line\">                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class=\"line\">                removePointersFromTouchTargets(idBitsToRemove);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class=\"line\">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //handled的值为dispatchTransformedTouchEvent的值，也就是onDispatchTouchEvent的值，也就是onTouchEvent的值，handled的初始值为false，</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><code>onFilterTouchEventForSecurity</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">根据这个方法的注释，很容易理解这个方法的含义</div><div class=\"line\">/**</div><div class=\"line\">     * Filter the touch event to apply security policies.</div><div class=\"line\">     *</div><div class=\"line\">     * @param event The motion event to be filtered.</div><div class=\"line\">     * @return True if the event should be dispatched, false if the event should be dropped.</div><div class=\"line\">     *</div><div class=\"line\">     * @see #getFilterTouchesWhenObscured</div><div class=\"line\">     */</div><div class=\"line\">    public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</div><div class=\"line\">        //noinspection RedundantIfStatement</div><div class=\"line\">        if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</div><div class=\"line\">                &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</div><div class=\"line\">            // Window is obscured, drop this touch.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>requestDisallowInterceptTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * &#123;@inheritDoc&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</div><div class=\"line\">            // We&apos;re already in this state, assume our ancestors are too</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (disallowIntercept) &#123;</div><div class=\"line\">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Pass it up to our parent</div><div class=\"line\">        if (mParent != null) &#123;</div><div class=\"line\">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><code>dispatchTransformedTouchEvent</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">     * Transforms a motion event into the coordinate space of a particular child view,</div><div class=\"line\">     * filters out irrelevant pointer ids, and overrides its action if necessary.</div><div class=\"line\">     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</div><div class=\"line\">     */</div><div class=\"line\">    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class=\"line\">            View child, int desiredPointerIdBits) &#123;</div><div class=\"line\">        final boolean handled;</div><div class=\"line\"></div><div class=\"line\">        // Canceling motions is a special case.  We don&apos;t need to perform any transformations</div><div class=\"line\">        // or filtering.  The important part is the action, not the contents.</div><div class=\"line\">        //看注释，就是这是处理特殊case的代码</div><div class=\"line\">        final int oldAction = event.getAction();</div><div class=\"line\">        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</div><div class=\"line\">            event.setAction(MotionEvent.ACTION_CANCEL);</div><div class=\"line\">            if (child == null) &#123;</div><div class=\"line\">                handled = super.dispatchTouchEvent(event);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handled = child.dispatchTouchEvent(event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            event.setAction(oldAction);</div><div class=\"line\">            return handled;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Calculate the number of pointers to deliver.</div><div class=\"line\">        final int oldPointerIdBits = event.getPointerIdBits();</div><div class=\"line\">        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</div><div class=\"line\"></div><div class=\"line\">        // If for some reason we ended up in an inconsistent state where it looks like we</div><div class=\"line\">        // might produce a motion event with no pointers in it, then drop the event.</div><div class=\"line\">        if (newPointerIdBits == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the number of pointers is the same and we don&apos;t need to perform any fancy</div><div class=\"line\">        // irreversible transformations, then we can reuse the motion event for this</div><div class=\"line\">        // dispatch as long as we are careful to revert any changes we make.</div><div class=\"line\">        // Otherwise we need to make a copy.</div><div class=\"line\">        final MotionEvent transformedEvent;</div><div class=\"line\">        //这个才是重点</div><div class=\"line\">        if (newPointerIdBits == oldPointerIdBits) &#123;</div><div class=\"line\">            if (child == null || child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                if (child == null) &#123;</div><div class=\"line\">                //这里child为null，其实代表的是viewgroup自己，而viewgroup的父类为view，所以这里的 super.dispatchTouchEvent(event)，意思就是调用viewgroup自己的dispatchTouchEvent，因为view没有onInterceptTouchEvent，进而调用自己的onTouchEvent，其实就是自己消费这次事件</div><div class=\"line\">                    handled = super.dispatchTouchEvent(event);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">                    final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">                    event.offsetLocation(offsetX, offsetY);</div><div class=\"line\">\t\t//chile不为null的话，就是调用子view 的dispatchTouchEvent事件，就是分发事件给子view</div><div class=\"line\">                    handled = child.dispatchTouchEvent(event);</div><div class=\"line\"></div><div class=\"line\">                    event.offsetLocation(-offsetX, -offsetY);</div><div class=\"line\">                &#125;</div><div class=\"line\">                return handled;</div><div class=\"line\">            &#125;</div><div class=\"line\">            transformedEvent = MotionEvent.obtain(event);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            transformedEvent = event.split(newPointerIdBits);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//这里和上面同理</div><div class=\"line\">        // Perform any necessary transformations and dispatch.</div><div class=\"line\">        if (child == null) &#123;</div><div class=\"line\">            handled = super.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            final float offsetX = mScrollX - child.mLeft;</div><div class=\"line\">            final float offsetY = mScrollY - child.mTop;</div><div class=\"line\">            transformedEvent.offsetLocation(offsetX, offsetY);</div><div class=\"line\">            if (! child.hasIdentityMatrix()) &#123;</div><div class=\"line\">                transformedEvent.transform(child.getInverseMatrix());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            handled = child.dispatchTouchEvent(transformedEvent);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Done.</div><div class=\"line\">        transformedEvent.recycle();</div><div class=\"line\">        //handled的值为调用dispatchTouchEvent的值，后面会看到这个值其实是OnTouchEvent的值</div><div class=\"line\">        return handled;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"View\"><a href=\"#View\" class=\"headerlink\" title=\"View\"></a>View</h3>"},{"title":"Android在Ubuntu上配置NDK的环境","_content":"由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。\n## 1.下载Android NDK压缩包\n[官网下载](https://developer.android.com/ndk/downloads/index.html)\nNDK有不同的版本，这里根据需要下载不同的版本。\n## 2.解压\n把第1部下载的压缩包解压，我这里存放的目录如下：\n```\n/home/kl/android-sdk-linux/android-nkd-r13b\n```\n## 3. 设置环境变量\n执行如下命令\n```\n$ sudo vim ~/.bashrc\n```\n然后经如下几句加进去：\n```\nexport ANDROID_HOME=\"/home/kl/android-sdk-linux\"\nexport PATH=\"$PATH:$ANDROID_NDK\"\n```\n关闭terminal，在打开就设置成功了，在验证一下是否成功：\n```\n$ ndk-build -v\nGNU Make 3.81\nCopyright (C) 2006  Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for x86_64-pc-linux-gnu\n```","source":"_posts/Ubuntu-Android-NDK.md","raw":"---\ntitle: Android在Ubuntu上配置NDK的环境\ncategories: Android\ntags: Ubuntu,Android\n---\n由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。\n## 1.下载Android NDK压缩包\n[官网下载](https://developer.android.com/ndk/downloads/index.html)\nNDK有不同的版本，这里根据需要下载不同的版本。\n## 2.解压\n把第1部下载的压缩包解压，我这里存放的目录如下：\n```\n/home/kl/android-sdk-linux/android-nkd-r13b\n```\n## 3. 设置环境变量\n执行如下命令\n```\n$ sudo vim ~/.bashrc\n```\n然后经如下几句加进去：\n```\nexport ANDROID_HOME=\"/home/kl/android-sdk-linux\"\nexport PATH=\"$PATH:$ANDROID_NDK\"\n```\n关闭terminal，在打开就设置成功了，在验证一下是否成功：\n```\n$ ndk-build -v\nGNU Make 3.81\nCopyright (C) 2006  Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for x86_64-pc-linux-gnu\n```","slug":"Ubuntu-Android-NDK","published":1,"date":"2017-02-26T09:11:22.469Z","updated":"2017-02-26T09:11:22.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqzwtw7000a5h2d749y3sx2","content":"<p>由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。</p>\n<h2 id=\"1-下载Android-NDK压缩包\"><a href=\"#1-下载Android-NDK压缩包\" class=\"headerlink\" title=\"1.下载Android NDK压缩包\"></a>1.下载Android NDK压缩包</h2><p><a href=\"https://developer.android.com/ndk/downloads/index.html\" target=\"_blank\" rel=\"external\">官网下载</a><br>NDK有不同的版本，这里根据需要下载不同的版本。</p>\n<h2 id=\"2-解压\"><a href=\"#2-解压\" class=\"headerlink\" title=\"2.解压\"></a>2.解压</h2><p>把第1部下载的压缩包解压，我这里存放的目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/home/kl/android-sdk-linux/android-nkd-r13b</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-设置环境变量\"><a href=\"#3-设置环境变量\" class=\"headerlink\" title=\"3. 设置环境变量\"></a>3. 设置环境变量</h2><p>执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo vim ~/.bashrc</div></pre></td></tr></table></figure></p>\n<p>然后经如下几句加进去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export ANDROID_HOME=&quot;/home/kl/android-sdk-linux&quot;</div><div class=\"line\">export PATH=&quot;$PATH:$ANDROID_NDK&quot;</div></pre></td></tr></table></figure></p>\n<p>关闭terminal，在打开就设置成功了，在验证一下是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ndk-build -v</div><div class=\"line\">GNU Make 3.81</div><div class=\"line\">Copyright (C) 2006  Free Software Foundation, Inc.</div><div class=\"line\">This is free software; see the source for copying conditions.</div><div class=\"line\">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</div><div class=\"line\">PARTICULAR PURPOSE.</div><div class=\"line\"></div><div class=\"line\">This program built for x86_64-pc-linux-gnu</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>由于自己一直在使用Ubuntu，所以Android的开发环境也在Ubuntu上搭建，在开发过程中，需要用到Android的交叉编译，所以把Android在Ubuntu上配置NDK环境的步骤记录一下。</p>\n<h2 id=\"1-下载Android-NDK压缩包\"><a href=\"#1-下载Android-NDK压缩包\" class=\"headerlink\" title=\"1.下载Android NDK压缩包\"></a>1.下载Android NDK压缩包</h2><p><a href=\"https://developer.android.com/ndk/downloads/index.html\">官网下载</a><br>NDK有不同的版本，这里根据需要下载不同的版本。</p>\n<h2 id=\"2-解压\"><a href=\"#2-解压\" class=\"headerlink\" title=\"2.解压\"></a>2.解压</h2><p>把第1部下载的压缩包解压，我这里存放的目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/home/kl/android-sdk-linux/android-nkd-r13b</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-设置环境变量\"><a href=\"#3-设置环境变量\" class=\"headerlink\" title=\"3. 设置环境变量\"></a>3. 设置环境变量</h2><p>执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo vim ~/.bashrc</div></pre></td></tr></table></figure></p>\n<p>然后经如下几句加进去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export ANDROID_HOME=&quot;/home/kl/android-sdk-linux&quot;</div><div class=\"line\">export PATH=&quot;$PATH:$ANDROID_NDK&quot;</div></pre></td></tr></table></figure></p>\n<p>关闭terminal，在打开就设置成功了，在验证一下是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ndk-build -v</div><div class=\"line\">GNU Make 3.81</div><div class=\"line\">Copyright (C) 2006  Free Software Foundation, Inc.</div><div class=\"line\">This is free software; see the source for copying conditions.</div><div class=\"line\">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</div><div class=\"line\">PARTICULAR PURPOSE.</div><div class=\"line\"></div><div class=\"line\">This program built for x86_64-pc-linux-gnu</div></pre></td></tr></table></figure></p>\n"},{"title":"Ubuntu下设置环境变量的几种方法和区别","_content":" 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。\n## 1.通过文件设置Ubuntu环境变量\n首先是设置全局环境变量，对所有用户都会生效：\n\n* etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。\n* /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。\n\n接着是与上述两个文件对应，但只对单个用户生效：\n\n* ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。\n* ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。\n\n此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：\n\n* 系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）\n* /etc/environment 中不能包含命令，即直接通过 VAR=\"...\" 的方式设置，不使用 export 。\n* 使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。\n\n## 2.通过 Shell 命令 export 修改 Linux 环境变量\n另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：\n```\n$ export PATH=$PATH:/usr/local/hadoop/bin\n\nexport 方式只对当前终端 Shell 有效\n使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。\n```\n\n","source":"_posts/Ubuntun-set-environment.md","raw":"---\ntitle: Ubuntu下设置环境变量的几种方法和区别\ncategories: Ubuntu\ntags: Ubuntu\n---\n 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。\n## 1.通过文件设置Ubuntu环境变量\n首先是设置全局环境变量，对所有用户都会生效：\n\n* etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。\n* /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。\n\n接着是与上述两个文件对应，但只对单个用户生效：\n\n* ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。\n* ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。\n\n此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：\n\n* 系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）\n* /etc/environment 中不能包含命令，即直接通过 VAR=\"...\" 的方式设置，不使用 export 。\n* 使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。\n\n## 2.通过 Shell 命令 export 修改 Linux 环境变量\n另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：\n```\n$ export PATH=$PATH:/usr/local/hadoop/bin\n\nexport 方式只对当前终端 Shell 有效\n使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。\n```\n\n","slug":"Ubuntun-set-environment","published":1,"date":"2017-02-26T08:38:02.343Z","updated":"2017-02-26T08:38:02.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqzwtw9000e5h2ddosl4kj1","content":"<p> 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。</p>\n<h2 id=\"1-通过文件设置Ubuntu环境变量\"><a href=\"#1-通过文件设置Ubuntu环境变量\" class=\"headerlink\" title=\"1.通过文件设置Ubuntu环境变量\"></a>1.通过文件设置Ubuntu环境变量</h2><p>首先是设置全局环境变量，对所有用户都会生效：</p>\n<ul>\n<li>etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。</li>\n<li>/etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。</li>\n</ul>\n<p>接着是与上述两个文件对应，但只对单个用户生效：</p>\n<ul>\n<li>~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。</li>\n<li>~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。</li>\n</ul>\n<p>此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：</p>\n<ul>\n<li>系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）</li>\n<li>/etc/environment 中不能包含命令，即直接通过 VAR=”…” 的方式设置，不使用 export 。</li>\n<li>使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。</li>\n</ul>\n<h2 id=\"2-通过-Shell-命令-export-修改-Linux-环境变量\"><a href=\"#2-通过-Shell-命令-export-修改-Linux-环境变量\" class=\"headerlink\" title=\"2.通过 Shell 命令 export 修改 Linux 环境变量\"></a>2.通过 Shell 命令 export 修改 Linux 环境变量</h2><p>另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ export PATH=$PATH:/usr/local/hadoop/bin</div><div class=\"line\"></div><div class=\"line\">export 方式只对当前终端 Shell 有效</div><div class=\"line\">使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p> 在Ubuntu下设置环境变量的方法总是搞混，今天写下来可以以后多看看。</p>\n<h2 id=\"1-通过文件设置Ubuntu环境变量\"><a href=\"#1-通过文件设置Ubuntu环境变量\" class=\"headerlink\" title=\"1.通过文件设置Ubuntu环境变量\"></a>1.通过文件设置Ubuntu环境变量</h2><p>首先是设置全局环境变量，对所有用户都会生效：</p>\n<ul>\n<li>etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。</li>\n<li>/etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。</li>\n</ul>\n<p>接着是与上述两个文件对应，但只对单个用户生效：</p>\n<ul>\n<li>~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。</li>\n<li>~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。</li>\n</ul>\n<p>此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意：</p>\n<ul>\n<li>系统先读取 etc/enviornmen 再读取 /etc/profile（还是反过来？）</li>\n<li>/etc/environment 中不能包含命令，即直接通过 VAR=”…” 的方式设置，不使用 export 。</li>\n<li>使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。</li>\n</ul>\n<h2 id=\"2-通过-Shell-命令-export-修改-Linux-环境变量\"><a href=\"#2-通过-Shell-命令-export-修改-Linux-环境变量\" class=\"headerlink\" title=\"2.通过 Shell 命令 export 修改 Linux 环境变量\"></a>2.通过 Shell 命令 export 修改 Linux 环境变量</h2><p>另一种修改 Linux 环境变量的方式就是通过 Shell 命令 export，注意变量名不要有美元号 $，赋值语句中才需要有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ export PATH=$PATH:/usr/local/hadoop/bin</div><div class=\"line\"></div><div class=\"line\">export 方式只对当前终端 Shell 有效</div><div class=\"line\">使用 export 设置的变量，只对当前终端 Shell 有效，也就是说如果新打开一个终端，那这个 export 设置的变量在新终端中使无法读取到的。适合设置一些临时变量。</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[{"_id":"source/_posts/ByteArrayInputStream/bytearrayinputstream.png","slug":"bytearrayinputstream.png","post":"cizqzwtvk00005h2d0m0xrz5y","modified":0,"renderable":0},{"_id":"source/_posts/ByteArrayInputStream/fileinputstream.png","slug":"fileinputstream.png","post":"cizqzwtvk00005h2d0m0xrz5y","modified":0,"renderable":0},{"_id":"source/_posts/ByteArrayInputStream/filterinputstream.png","slug":"filterinputstream.png","post":"cizqzwtvk00005h2d0m0xrz5y","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/file.jpg","slug":"file.jpg","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/inputstream.png","slug":"inputstream.png","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/outputstream.png","slug":"outputstream.png","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/reader.png","slug":"reader.png","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/socket.jpg","slug":"socket.jpg","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0},{"_id":"source/_posts/Java-IO/writer.png","slug":"writer.png","post":"cizqzwtvq00025h2dycpwkcrv","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cizqzwtvk00005h2d0m0xrz5y","category_id":"cizqzwtvt00045h2dsv62tmuy","_id":"cizqzwtwa000f5h2di1y255xs"},{"post_id":"cizqzwtvq00025h2dycpwkcrv","category_id":"cizqzwtw8000b5h2disx3qwcj","_id":"cizqzwtwb000j5h2dbt1ip0fy"},{"post_id":"cizqzwtvy00065h2dhd3pqq71","category_id":"cizqzwtwb000g5h2dqrqlq9sk","_id":"cizqzwtwg000n5h2dq2e0uoku"},{"post_id":"cizqzwtw100085h2dxelhm3rk","category_id":"cizqzwtwc000k5h2di4h799en","_id":"cizqzwtwi000r5h2dy8i8gft0"},{"post_id":"cizqzwtw7000a5h2d749y3sx2","category_id":"cizqzwtwc000k5h2di4h799en","_id":"cizqzwtwk000v5h2d7tl59lkx"},{"post_id":"cizqzwtw9000e5h2ddosl4kj1","category_id":"cizqzwtwj000s5h2d5tdsapq6","_id":"cizqzwtwl000x5h2dp4il7q0g"}],"PostTag":[{"post_id":"cizqzwtvk00005h2d0m0xrz5y","tag_id":"cizqzwtvx00055h2dm8nrixsm","_id":"cizqzwtw8000d5h2dbn5q91hn"},{"post_id":"cizqzwtvq00025h2dycpwkcrv","tag_id":"cizqzwtw8000c5h2drtfcmyy4","_id":"cizqzwtwb000i5h2dkyzyq9nm"},{"post_id":"cizqzwtvy00065h2dhd3pqq71","tag_id":"cizqzwtwb000h5h2drsiufyn5","_id":"cizqzwtwe000m5h2d1ve0bs9j"},{"post_id":"cizqzwtw100085h2dxelhm3rk","tag_id":"cizqzwtwd000l5h2dwlyiz8nv","_id":"cizqzwtwi000q5h2dtdmby5qs"},{"post_id":"cizqzwtw7000a5h2d749y3sx2","tag_id":"cizqzwtwg000p5h2du5ygwu90","_id":"cizqzwtwk000u5h2dvnekzx79"},{"post_id":"cizqzwtw9000e5h2ddosl4kj1","tag_id":"cizqzwtwj000t5h2dp60rch32","_id":"cizqzwtwk000w5h2de63cbtsy"}],"Tag":[{"name":"Java","_id":"cizqzwtvx00055h2dm8nrixsm"},{"name":"Java,I/O","_id":"cizqzwtw8000c5h2drtfcmyy4"},{"name":"TensorFlow,Android","_id":"cizqzwtwb000h5h2drsiufyn5"},{"name":"Android","_id":"cizqzwtwd000l5h2dwlyiz8nv"},{"name":"Ubuntu,Android","_id":"cizqzwtwg000p5h2du5ygwu90"},{"name":"Ubuntu","_id":"cizqzwtwj000t5h2dp60rch32"}]}}